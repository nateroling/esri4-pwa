"use strict";var Xt=Object.defineProperty,Bt=Object.getOwnPropertySymbols,Yt=Object.prototype.hasOwnProperty,Nt=Object.prototype.propertyIsEnumerable,Ht=(Tt,gt,R)=>gt in Tt?Xt(Tt,gt,{enumerable:!0,configurable:!0,writable:!0,value:R}):Tt[gt]=R,Ut=(Tt,gt)=>{for(var R in gt||(gt={}))Yt.call(gt,R)&&Ht(Tt,R,gt[R]);if(Bt)for(var R of Bt(gt))Nt.call(gt,R)&&Ht(Tt,R,gt[R]);return Tt};(self.webpackChunkesri4_pwa=self.webpackChunkesri4_pwa||[]).push([[5909],{986:(Tt,gt,R)=>{R.d(gt,{E:()=>Z});const W=new(R(6879).Z);function Z(ht){if(!W.hasBidiChar(ht))return[ht,!1];let St;return St="rtl"===W.checkContextual(ht)?"IDNNN":"ICNNN",[W.bidiTransform(ht,St,"VLYSN"),!0]}},36161:(Tt,gt,R)=>{R.d(gt,{I:()=>W,v:()=>Z});var ut=R(21286);function W(T,F,N=0){const K=(0,ut.uZ)(T,0,x);for(let rt=0;rt<4;rt++)F[N+rt]=Math.floor(256*wt(K*ht[rt]))}function Z(T,F=0){let N=0;for(let K=0;K<4;K++)N+=T[F+K]*St[K];return N}const ht=[1,256,65536,16777216],St=[1/256,1/65536,1/16777216,1/4294967296],x=Z(new Uint8ClampedArray([255,255,255,255]));function wt(T){return T-Math.floor(T)}},72283:(Tt,gt,R)=>{R.d(gt,{zY:()=>Rt,v1:()=>zt,GP:()=>ht,wp:()=>J,XV:()=>bt,zv:()=>Lt,QK:()=>Ct,ov:()=>et,hh:()=>mt,qh:()=>Et});var ut=R(58817),W=R(91179),Z=R(97373);function ht(w){const V=(0,ut.d9)(w);return function rt(w){w&&((0,W.oU)(w)?K(w.rings):(0,W.l9)(w)?K(w.paths):(0,W.aW)(w)&&N(w.points),St(w))}(V),V}function St(w){if(!w)return null;(0,W.wp)(w)?w.y=-w.y:(0,W.oU)(w)?wt(w.rings):(0,W.l9)(w)?wt(w.paths):(0,W.aW)(w)&&x(w.points)}function x(w){if(w){const V=w.length;for(let Q=0;Q<V;Q++)w[Q][1]=-w[Q][1]}}function wt(w){if(w)for(const V of w)x(V)}function T(w){if(w)for(let V=w.length-1;V>0;--V)w[V][0]-=w[V-1][0],w[V][1]-=w[V-1][1]}function F(w){if(w)for(const V of w)T(V)}function N(w){if(w){const V=w.length;for(let Q=1;Q<V;++Q)w[Q][0]+=w[Q-1][0],w[Q][1]+=w[Q-1][1]}}function K(w){if(w)for(const V of w)N(V)}function J(w){w&&(St(w),(0,W.oU)(w)?F(w.rings):(0,W.l9)(w)?F(w.paths):(0,W.aW)(w)&&T(w.points))}function et(w){if(w)for(const V of w)mt(V)}function mt(w){w&&w.reverse()}function bt(w,V,Q){return[w[0]+(V[0]-w[0])*Q,w[1]+(V[1]-w[1])*Q]}function Ct(w){return!(!w||0===w.length)&&w[0][0]===w[w.length-1][0]&&w[0][1]===w[w.length-1][1]}function Lt(w){return w[4]}function Et(w,V){w[4]=V}class zt{constructor(V,Q,E,D){this.acceptPolygon=Q,this.acceptPolyline=E,this.geomUnitsPerPoint=D,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,V&&((0,W.oU)(V)?Q&&(this.multiPath=V.rings,this.isClosed=!0):(0,W.l9)(V)?E&&(this.multiPath=V.paths,this.isClosed=!1):(0,W.YX)(V)&&Q&&(this.multiPath=ot(V).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new Z.u}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const V=this.processPath(this.multiPath[this.pathIndex]);if(V)return V}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class Rt{constructor(V,Q,E,D){this.inputGeometries=V,this.acceptPolygon=Q,this.acceptPolyline=E,this.geomUnitsPerPoint=D,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let V=this.inputGeometries.next();for(;V;){if((0,W.oU)(V)?this.acceptPolygon&&(this.multiPath=V.rings,this.isClosed=!0):(0,W.l9)(V)?this.acceptPolyline&&(this.multiPath=V.paths,this.isClosed=!1):(0,W.YX)(V)&&this.acceptPolygon&&(this.multiPath=ot(V).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}V=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const V=this.processPath(this.multiPath[this.pathIndex]);if(V)return V}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function ot(w){return{rings:[[[w.xmin,w.ymin],[w.xmin,w.ymax],[w.xmax,w.ymax],[w.xmax,w.ymin],[w.xmin,w.ymin]]]}}},29214:(Tt,gt,R)=>{R.d(gt,{M:()=>W}),R(58817);class W{constructor(St){this._geometry=St}next(){const St=this._geometry;return this._geometry=null,St}}},11004:(Tt,gt,R)=>{R.d(gt,{h:()=>Ft,W:()=>Ot});var ut=R(58817),W=R(91179),Z=R(72283);let ht=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new St(e,i,a)}}return f.instance=null,f})();class St{constructor(s,e,i){this._inputGeometries=s,this._angleTolerance=void 0!==e.angleTolerance?e.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.oU)(s)){this._isClosed=!0;const e=(0,ut.d9)(s);return this._processMultipath(e.rings),e}if((0,W.l9)(s)){this._isClosed=!1;const e=(0,ut.d9)(s);return this._processMultipath(e.paths),e}if((0,W.YX)(s)){if(this._maxCosAngle)return s;this._isClosed=!0;const e=[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]];return this._processPath(e),{rings:[e]}}s=this._inputGeometries.next()}return null}_processMultipath(s){if(s)for(const e of s)this._processPath(e)}_processPath(s){if(s){let e,i,a,n,r,c,h=s.length,u=s[0];this._isClosed&&++h;for(let p=1;p<h;++p){let d;d=this._isClosed&&p===h-1?s[0]:s[p];const A=d[0]-u[0],z=d[1]-u[1],G=Math.sqrt(A*A+z*z);p>1&&G>0&&a>0&&(e*A+i*z)/G/a<=this._maxCosAngle&&(0,Z.qh)(u,1),1===p&&(n=A,r=z,c=G),G>0&&(u=d,e=A,i=z,a=G)}this._isClosed&&a>0&&c>0&&(e*n+i*r)/c/a<=this._maxCosAngle&&(0,Z.qh)(s[0],1)}}}var x=R(7547);const wt=.03;class T{constructor(){this._path=[]}path(){return this._path}addPath(s,e){e||s.reverse(),Array.prototype.push.apply(this._path,s),e||s.reverse()}static mergePath(s,e){e&&Array.prototype.push.apply(s,e)}startPath(s){this._path.push(s)}lineTo(s){this._path.push(s)}close(){const s=this._path;s.length>1&&(s[0][0]===s[s.length-1][0]&&s[0][1]===s[s.length-1][1]||s.push([s[0][0],s[0][1]]))}}class F{constructor(s=0,e=!1){}normalize(s){const e=Math.sqrt(s[0]*s[0]+s[1]*s[1]);s[0]/=e,s[1]/=e}calculateLength(s,e){const i=e[0]-s[0],a=e[1]-s[1];return Math.sqrt(i*i+a*a)}calculateSegLength(s,e){return this.calculateLength(s[e],s[e+1])}calculatePathLength(s){let e=0;const i=s?s.length:0;for(let a=0;a<i-1;++a)e+=this.calculateSegLength(s,a);return e}calculatePathArea(s){let e=0;const i=s?s.length:0;for(let a=0;a<i-1;++a)e+=(s[a+1][0]-s[a][0])*(s[a+1][1]+s[a][1]);return e/2}getCoord2D(s,e,i){return[s[0]+(e[0]-s[0])*i,s[1]+(e[1]-s[1])*i]}getSegCoord2D(s,e,i){return this.getCoord2D(s[e],s[e+1],i)}getAngle(s,e,i){return Math.atan2(e[1]-s[1],e[0]-s[0])}getSegAngle(s,e,i){return this.getAngle(s[e],s[e+1],i)}getAngleCS(s,e,i){const a=e[0]-s[0],n=e[1]-s[1],r=Math.sqrt(a*a+n*n);return r>0?[a/r,n/r]:[1,0]}getSegAngleCS(s,e,i){return this.getAngleCS(s[e],s[e+1],i)}cut(s,e,i,a){return[i<=0?s[e]:this.getSegCoord2D(s,e,i),a>=1?s[e+1]:this.getSegCoord2D(s,e,a)]}addSegment(s,e,i){i&&s.push(e[0]),s.push(e[1])}getSubCurve(s,e,i){const a=[];return this.appendSubCurve(a,s,e,i)?a:null}appendSubCurve(s,e,i,a){const n=e?e.length-1:0;let r=0,c=!0,h=0;for(;h<n;){const u=this.calculateSegLength(e,h);if(0!==u){if(c){if(r+u>i){let d=1,A=!1;r+u>=a&&(d=(a-r)/u,A=!0);const z=this.cut(e,h,(i-r)/u,d);if(z&&this.addSegment(s,z,c),A)break;c=!1}}else{if(r+u>a){const p=this.cut(e,h,0,(a-r)/u);p&&this.addSegment(s,p,c);break}this.addSegment(s,[e[h],e[h+1]],c)}r+=u,++h}else++h}return!0}getCIMPointAlong(s,e){const i=s?s.length-1:0;let a=0,n=-1;for(;n<i;){++n;const r=this.calculateSegLength(s,n);if(0!==r){if(a+r>e)return this.getCoord2D(s[n],s[n+1],(e-a)/r);a+=r}}return null}isEmpty(s,e){if(!s||s.length<=1)return!0;const i=s?s.length-1:0;let a=-1;for(;a<i;)if(++a,s[a+1][0]!==s[a][0]||s[a+1][1]!==s[a][1]||e&&s[a+1][2]!==s[a][2])return!1;return!0}offset(s,e,i,a,n){if(!s||s.length<2)return null;let r=0,c=s[r++],h=r;for(;r<s.length;){const A=s[r];A[0]===c[0]&&A[1]===c[1]||(r!==h&&(s[h]=s[r]),c=s[h++]),r++}const u=s[0][0]===s[h-1][0]&&s[0][1]===s[h-1][1];if(u&&--h,h<(u?3:2))return null;const p=[];c=u?s[h-1]:null;let d=s[0];for(let A=0;A<h;A++){const z=A===h-1?u?s[0]:null:s[A+1];if(c)if(z){const G=[z[0]-d[0],z[1]-d[1]];this.normalize(G);const B=[d[0]-c[0],d[1]-c[1]];this.normalize(B);const q=B[0]*G[1]-B[1]*G[0],At=B[0]*G[0]+B[1]*G[1];if(q>=0==e<=0){if(At<1){const kt=[G[0]-B[0],G[1]-B[1]];this.normalize(kt);const vt=Math.sqrt((1+At)/2);if(vt>1/a){const yt=-Math.abs(e)/vt;p.push([d[0]-kt[0]*yt,d[1]-kt[1]*yt])}}}else switch(i){case x.id.Mitered:{const kt=Math.sqrt((1+At)/2);if(kt>0&&1/kt<a){const vt=[G[0]-B[0],G[1]-B[1]];this.normalize(vt);const yt=Math.abs(e)/kt;p.push([d[0]-vt[0]*yt,d[1]-vt[1]*yt]);break}}case x.id.Bevelled:p.push([d[0]+B[1]*e,d[1]-B[0]*e]),p.push([d[0]+G[1]*e,d[1]-G[0]*e]);break;case x.id.Rounded:if(At<1){p.push([d[0]+B[1]*e,d[1]-B[0]*e]);const kt=Math.floor(2.5*(1-At));if(kt>0){const vt=1/kt;let yt=vt;for(let Wt=1;Wt<kt;Wt++,yt+=vt){const Gt=[B[1]*(1-yt)+G[1]*yt,-B[0]*(1-yt)-G[0]*yt];this.normalize(Gt),p.push([d[0]+Gt[0]*e,d[1]+Gt[1]*e])}}p.push([d[0]+G[1]*e,d[1]-G[0]*e])}break;default:if(q<0)p.push([d[0]+(B[1]+B[0])*e,d[1]+(B[1]-B[0])*e]),p.push([d[0]+(G[1]-G[0])*e,d[1]-(G[0]+G[1])*e]);else{const kt=Math.sqrt((1+Math.abs(At))/2),vt=[G[0]-B[0],G[1]-B[1]];this.normalize(vt);const yt=e/kt;p.push([d[0]-vt[0]*yt,d[1]-vt[1]*yt])}}}else{const G=[d[0]-c[0],d[1]-c[1]];this.normalize(G),p.push([d[0]+G[1]*e,d[1]-G[0]*e])}else{const G=[z[0]-d[0],z[1]-d[1]];this.normalize(G),p.push([d[0]+G[1]*e,d[1]-G[0]*e])}c=d,d=z}return p.length<(u?3:2)?null:(u&&p.push([p[0][0],p[0][1]]),p)}}const N=1.7320508075688772,rt=x.TF.OpenEnded;let J=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new et(e,i,a)}}return f.instance=null,f})();class et extends Z.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new F,this._width=(void 0!==e.width?e.width:5)*i,this._arrowType=void 0!==e.geometricEffectArrowType?e.geometricEffectArrowType:void 0!==e.arrowType?e.arrowType:rt,this._offsetFlattenError=wt*i}processPath(s){switch(this._arrowType){case x.TF.OpenEnded:default:return this._constructSimpleArrow(s,!0);case x.TF.Block:return this._constructSimpleArrow(s,!1);case x.TF.Crossed:return this._constructCrossedArrow(s)}}_constructSimpleArrow(s,e){const i=this._curveHelper.calculatePathLength(s);let a=this._width;i<2*a&&(a=i/2);const n=this._curveHelper.getSubCurve(s,0,i-a);if(!n)return null;const r=a/2;if(this._curveHelper.isEmpty(n,!1))return null;const c=this._constructOffset(n,-r);if(!c)return null;const h=this._constructOffset(n,r);if(!h)return null;const u=this._constructArrowBasePoint(c,-r/2);if(!u)return null;const p=this._constructArrowBasePoint(h,r/2);if(!p)return null;const d=s[s.length-1];e||(this._makeControlPoint(h,!0),this._makeControlPoint(c,!0));const A=new T;return A.addPath(h,!0),A.lineTo(p),this._makeControlPoint(A.path()),A.lineTo(d),this._makeControlPoint(A.path()),A.lineTo(u),this._makeControlPoint(A.path()),A.addPath(c,!1),e?{paths:[A.path()]}:(A.close(),{rings:[A.path()]})}_constructCrossedArrow(s){const e=this._curveHelper.calculatePathLength(s);let i=this._width;e<i*(1+N+1)&&(i=e/(1+N+1));const a=this._curveHelper.getSubCurve(s,0,e-i*(1+N));if(!a)return null;const n=i/2;if(this._curveHelper.isEmpty(a,!1))return null;const r=this._constructOffset(a,n);if(!r)return null;const c=this._constructOffset(a,-n);if(!c)return null;const h=this._curveHelper.getSubCurve(s,0,e-i);if(!h||this._curveHelper.isEmpty(h,!1))return null;const u=this._constructOffset(h,n);if(!u)return null;const p=this._constructOffset(h,-n);if(!p)return null;const d=u[u.length-1],A=this._constructArrowBasePoint(u,n/2);if(!A)return null;const z=p[p.length-1],G=this._constructArrowBasePoint(p,-n/2);if(!G)return null;const B=s[s.length-1];this._makeControlPoint(r,!1),this._makeControlPoint(c,!1);const q=new T;return q.addPath(r,!0),this._makeControlPoint(q.path()),q.lineTo(z),q.lineTo(G),this._makeControlPoint(q.path()),q.lineTo(B),this._makeControlPoint(q.path()),q.lineTo(A),this._makeControlPoint(q.path()),q.lineTo(d),this._makeControlPoint(q.path()),q.addPath(c,!1),{paths:[q.path()]}}_constructOffset(s,e){return this._curveHelper.offset(s,e,x.id.Rounded,4,this._offsetFlattenError)}_constructArrowBasePoint(s,e){if(!s||s.length<2)return null;const i=s[s.length-2],a=s[s.length-1],n=[a[0]-i[0],a[1]-i[1]];return this._curveHelper.normalize(n),[a[0]+n[1]*e,a[1]-n[0]*e]}_makeControlPoint(s,e=!1){(0,Z.qh)(e?s[0]:s[s.length-1],1)}}let mt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new bt(e,i,a,n)}}return f.instance=null,f})();class bt{constructor(s,e,i,a){this._inputGeometries=s,this._curveHelper=new F,this._size=(void 0!==e.size?e.size:1)*i,this._offsetFlattenError=wt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s))if(this._size>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],this._size,x.id.Rounded,4,this._offsetFlattenError);if(i)return{rings:[i]}}else{if(!(this._size<0))return s;if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._size>0)return{xmin:s.xmin-this._size,xmax:s.xmax+this._size,ymin:s.ymin-this._size,ymax:s.ymax+this._size}}if((0,W.oU)(s)){if(0===this._size)return s;const e=[];for(const i of s.rings){const a=this._curveHelper.offset(i,this._size,x.id.Rounded,4,this._offsetFlattenError);a&&e.push(a)}if(e.length)return{rings:e}}if((0,W.l9)(s)&&this._size>0){const e=[];for(const i of s.paths)if(i&&i.length>1){const a=this._curveHelper.offset(i,this._size,x.id.Rounded,4,this._offsetFlattenError),n=this._curveHelper.offset(i,-this._size,x.id.Rounded,4,this._offsetFlattenError);if(a&&n){for(let r=n.length-1;r>=0;r--)a.push(n[r]);a.push([a[0][0],a[0][1]]),e.push(a)}}if(e.length)return{rings:e}}(0,W.wp)(s),s=this._inputGeometries.next()}return null}}let Ct=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new Lt(e,i,a)}}return f.instance=null,f})();class Lt{constructor(s,e,i){var a;this._default_point_size=20,this._inputGeometries=s,this._geomUnitsPerPoint=i,this._rule=null!=(a=e.rule)?a:x.Em.FullGeometry,this._default_size=this._default_point_size*i}next(){let s;for(;s=this._inputGeometries.next();){let e;if((0,W.wp)(s)?e=this._processGeom([[[s.x,s.y]]]):(0,W.aW)(s)?e=this._processGeom([s.points]):(0,W.l9)(s)?e=this._processGeom(s.paths):(0,W.oU)(s)&&(e=this._processGeom(s.rings)),e&&e.length)return{paths:e}}return null}_clone(s){return[s[0],s[1]]}_mid(s,e){return[(s[0]+e[0])/2,(s[1]+e[1])/2]}_mix(s,e,i,a){return[s[0]*e+i[0]*a,s[1]*e+i[1]*a]}_add(s,e){return[s[0]+e[0],s[1]+e[1]]}_add2(s,e,i){return[s[0]+e,s[1]+i]}_sub(s,e){return[s[0]-e[0],s[1]-e[1]]}_dist(s,e){return Math.sqrt((s[0]-e[0])*(s[0]-e[0])+(s[1]-e[1])*(s[1]-e[1]))}_norm(s){return Math.sqrt(s[0]*s[0]+s[1]*s[1])}_normalize(s,e=1){const i=e/this._norm(s);s[0]*=i,s[1]*=i}_leftPerpendicular(s){const i=s[0];s[0]=-s[1],s[1]=i}_leftPerp(s){return[-s[1],s[0]]}_rightPerpendicular(s){const i=-s[0];s[0]=s[1],s[1]=i}_rightPerp(s){return[s[1],-s[0]]}_dotProduct(s,e){return s[0]*e[0]+s[1]*e[1]}_crossProduct(s,e){return s[0]*e[1]-s[1]*e[0]}_rotateDirect(s,e,i){const n=s[0]*i+s[1]*e;s[0]=s[0]*e-s[1]*i,s[1]=n}_makeCtrlPt(s){const e=[s[0],s[1]];return(0,Z.qh)(e,1),e}_addAngledTicks(s,e,i,a){const n=this._sub(i,e);this._normalize(n);const r=this._crossProduct(n,this._sub(a,e));let c;c=r>0?this._rightPerp(n):this._leftPerp(n);const h=Math.abs(r)/2,u=[];u.push([e[0]+(c[0]-n[0])*h,e[1]+(c[1]-n[1])*h]),u.push(e),u.push(i),u.push([i[0]+(c[0]+n[0])*h,i[1]+(c[1]+n[1])*h]),s.push(u)}_addBezier2(s,e,i,a,n){if(0==n--)return void s.push(a);const r=this._mid(e,i),c=this._mid(i,a),h=this._mid(r,c);this._addBezier2(s,e,r,h,n),this._addBezier2(s,h,c,a,n)}_addBezier3(s,e,i,a,n,r){if(0==r--)return void s.push(n);const c=this._mid(e,i),h=this._mid(i,a),u=this._mid(a,n),p=this._mid(c,h),d=this._mid(h,u),A=this._mid(p,d);this._addBezier3(s,e,c,p,A,r),this._addBezier3(s,A,d,u,n,r)}_add90DegArc(s,e,i,a,n){const r=null!=n?n:this._crossProduct(this._sub(i,e),this._sub(a,e))>0,c=this._mid(e,i),h=this._sub(c,e);r?this._leftPerpendicular(h):this._rightPerpendicular(h),c[0]+=h[0],c[1]+=h[1],this._addBezier3(s,e,this._mix(e,.33333,c,.66667),this._mix(i,.33333,c,.66667),i,4)}_addArrow(s,e,i){const a=e[0],n=e[1],r=e[e.length-1],c=this._sub(a,n);this._normalize(c);const h=this._crossProduct(c,this._sub(r,n)),u=.5*h,p=this._leftPerp(c),d=[r[0]-p[0]*h,r[1]-p[1]*h],A=e.length-1,z=[];z.push(i?[-p[0],-p[1]]:p);let G=[-c[0],-c[1]];for(let B=1;B<A-1;B++){const q=this._sub(e[B+1],e[B]);this._normalize(q);const At=this._dotProduct(q,G),kt=this._crossProduct(q,G),vt=Math.sqrt((1+At)/2),yt=this._sub(q,G);this._normalize(yt),yt[0]/=vt,yt[1]/=vt,z.push(kt<0?[-yt[0],-yt[1]]:yt),G=q}z.push(this._rightPerp(G));for(let B=z.length-1;B>0;B--)s.push([e[B][0]+z[B][0]*u,e[B][1]+z[B][1]*u]);s.push([d[0]+z[0][0]*u,d[1]+z[0][1]*u]),s.push([d[0]+z[0][0]*h,d[1]+z[0][1]*h]),s.push(a),s.push([d[0]-z[0][0]*h,d[1]-z[0][1]*h]),s.push([d[0]-z[0][0]*u,d[1]-z[0][1]*u]);for(let B=1;B<z.length;B++)s.push([e[B][0]-z[B][0]*u,e[B][1]-z[B][1]*u])}_cp2(s,e,i){return s.length>=2?s[1]:this._add2(s[0],e*this._default_size,i*this._default_size)}_cp3(s,e,i,a){if(s.length>=3)return s[2];const n=this._mix(s[0],1-i,e,i),r=this._sub(e,s[0]);return this._normalize(r),this._rightPerpendicular(r),[n[0]+r[0]*a*this._default_size,n[1]+r[1]*a*this._default_size]}_arrowPath(s){if(s.length>2)return s;const e=s[0],i=this._cp2(s,-4,0),a=this._sub(e,i);this._normalize(a);const n=this._rightPerp(a);return[e,i,[e[0]+(n[0]-a[0])*this._default_size,e[1]+(n[1]-a[1])*this._default_size]]}_arrowLastSeg(s){const e=s[0],i=this._cp2(s,-4,0);let a;if(s.length>=3)a=s[s.length-1];else{const n=this._sub(e,i);this._normalize(n);const r=this._rightPerp(n);a=[e[0]+(r[0]-n[0])*this._default_size,e[1]+(r[1]-n[1])*this._default_size]}return[i,a]}_processGeom(s){if(!s)return null;const e=[];for(const i of s){if(!i||0===i.length)continue;const a=i.length;let n=i[0];switch(this._rule){case x.Em.PerpendicularFromFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=[];h.push(c),h.push(this._mid(n,r)),e.push(h);break}case x.Em.ReversedFirstSegment:{const r=this._cp2(i,0,-1);e.push([r,n]);break}case x.Em.PerpendicularToSecondSegment:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=[];h.push(this._mid(r,c)),h.push(n),e.push(h);break}case x.Em.SecondSegmentWithTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);let u;u=this._crossProduct(h,this._sub(n,r))>0?this._rightPerp(u):this._leftPerp(h);const p=[];p.push([r[0]+(u[0]-h[0])/3,r[1]+(u[1]-h[1])/3]),p.push(r),p.push(c),p.push([c[0]+(u[0]+h[0])/3,c[1]+(u[1]+h[1])/3]),e.push(p);break}case x.Em.DoublePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const d=[];d.push(n),d.push([c[0]+u[0]*p,c[1]+u[1]*p]),e.push(d);const A=[];A.push([c[0]-u[0]*p,c[1]-u[1]*p]),A.push(r),e.push(A);break}case x.Em.OppositeToFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,3),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const d=[];d.push([c[0]+u[0]*p,c[1]+u[1]*p]),d.push([c[0]-u[0]*p,c[1]-u[1]*p]),e.push(d);break}case x.Em.TriplePerpendicular:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(n,r),u=this._sub(h,c);this._normalize(u);const p=this._crossProduct(u,this._sub(n,c));this._leftPerpendicular(u);const d=[];d.push([c[0]+u[0]*p*.8,c[1]+u[1]*p*.8]),d.push([h[0]+.8*(n[0]-h[0]),h[1]+.8*(n[1]-h[1])]),e.push(d),e.push([c,h]);const A=[];A.push([c[0]-u[0]*p*.8,c[1]-u[1]*p*.8]),A.push([h[0]+.8*(r[0]-h[0]),h[1]+.8*(r[1]-h[1])]),e.push(A);break}case x.Em.HalfCircleFirstSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,4),h=this._mid(n,r);let u=this._sub(r,n);const p=Math.cos(Math.PI/18),d=Math.sin(Math.PI/18),A=Math.sqrt((1+p)/2),z=Math.sqrt((1-p)/2),G=[];let B;this._crossProduct(u,this._sub(c,n))>0?(G.push(n),u=this._sub(n,h),B=r):(G.push(r),u=this._sub(r,h),B=n),this._rotateDirect(u,A,z),u[0]/=A,u[1]/=A;for(let q=1;q<=18;q++)G.push(this._add(h,u)),this._rotateDirect(u,p,d);G.push(B),e.push(G);break}case x.Em.HalfCircleSecondSegment:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,1,-1);let h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r))/2;this._leftPerpendicular(h);const p=[r[0]+h[0]*u,r[1]+h[1]*u];h=this._sub(r,p);const d=Math.cos(Math.PI/18);let A=Math.sin(Math.PI/18);u>0&&(A=-A);const z=[r];for(let G=1;G<=18;G++)this._rotateDirect(h,d,A),z.push(this._add(p,h));e.push(z);break}case x.Em.HalfCircleExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-1);let h;if(a>=4)h=i[3];else{const G=this._sub(n,r);h=this._add(c,G)}const u=this._dist(r,c)/2/.75,p=this._sub(r,n);this._normalize(p,u);const d=this._sub(c,h);this._normalize(d,u),e.push([h,c]);const z=[this._clone(c)];this._addBezier3(z,c,this._add(c,d),this._add(r,p),r,4),z.push(n),e.push(z);break}case x.Em.OpenCircle:{const r=this._cp2(i,-2,0),c=this._sub(r,n),h=Math.cos(Math.PI/18),u=-Math.sin(Math.PI/18),p=[r];for(let d=1;d<=33;d++)this._rotateDirect(c,h,u),p.push(this._add(n,c));e.push(p);break}case x.Em.CoverageEdgesWithTicks:{const r=this._cp2(i,0,-1);let c,h;if(a>=3)c=i[2];else{const A=this._sub(r,n),z=this._leftPerp(A);c=[n[0]+z[0]-.25*A[0],n[1]+z[1]-.25*A[1]]}if(a>=4)h=i[3];else{const A=this._mid(n,r),z=this._sub(n,r);this._normalize(z),this._leftPerpendicular(z);const G=this._crossProduct(z,this._sub(c,A));this._rightPerpendicular(z),h=[c[0]+z[0]*G*2,c[1]+z[1]*G*2]}const u=this._sub(r,n);let p,d;p=this._crossProduct(u,this._sub(c,n))>0?this._rightPerp(u):this._leftPerp(u),d=[],d.push(c),d.push(n),d.push([n[0]+(p[0]-u[0])/3,n[1]+(p[1]-u[1])/3]),e.push(d),p=this._crossProduct(u,this._sub(h,r))>0?this._rightPerp(p):this._leftPerp(u),d=[],d.push([r[0]+(p[0]+u[0])/3,r[1]+(p[1]+u[1])/3]),d.push(r),d.push(h),e.push(d);break}case x.Em.GapExtentWithDoubleTicks:{const r=this._cp2(i,0,2),c=this._cp3(i,r,0,1);let h;if(a>=4)h=i[3];else{const u=this._sub(r,n);h=this._add(c,u)}this._addAngledTicks(e,n,r,this._mid(c,h)),this._addAngledTicks(e,c,h,this._mid(n,r));break}case x.Em.GapExtentMidline:{const r=this._cp2(i,2,0),c=this._cp3(i,r,0,1);let h;if(a>=4)h=i[3];else{const p=this._sub(r,n);h=this._add(c,p)}const u=[];u.push(this._mid(n,c)),u.push(this._mid(r,h)),e.push(u);break}case x.Em.Chevron:{const r=this._cp2(i,-1,-1);let c;if(a>=3)c=i[2];else{const h=this._sub(r,n);this._leftPerpendicular(h),c=this._add(n,h)}e.push([r,this._makeCtrlPt(n),c]);break}case x.Em.PerpendicularWithArc:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,.5,-1);let h=this._sub(r,n);const u=this._norm(h);h[0]/=u,h[1]/=u;const p=this._crossProduct(h,this._sub(c,n));let d=this._dotProduct(h,this._sub(c,n));d<.05*u?d=.05*u:d>.95*u&&(d=.95*u);const A=[n[0]+h[0]*d,n[1]+h[1]*d];this._leftPerpendicular(h);let z=[];z.push([A[0]-h[0]*p,A[1]-h[1]*p]),z.push([A[0]+h[0]*p,A[1]+h[1]*p]),e.push(z);const G=[r[0]+h[0]*p,r[1]+h[1]*p];h=this._sub(r,G);const B=Math.cos(Math.PI/18);let q=Math.sin(Math.PI/18);p<0&&(q=-q),z=[n,r];for(let At=1;At<=9;At++)this._rotateDirect(h,B,q),z.push(this._add(G,h));e.push(z);break}case x.Em.ClosedHalfCircle:{const r=this._cp2(i,2,0),c=this._mid(n,r),h=this._sub(r,c),u=Math.cos(Math.PI/18),p=Math.sin(Math.PI/18),d=[n,r];for(let A=1;A<=18;A++)this._rotateDirect(h,u,p),d.push(this._add(c,h));e.push(d);break}case x.Em.TripleParallelExtended:{const r=this._cp2(i,0,-2),c=this._cp3(i,r,1,-2),h=this._mid(n,r),u=this._sub(c,r);this._normalize(u);const p=Math.abs(this._crossProduct(u,this._sub(h,r)))/2,d=this._dist(r,c),A=[r,n];A.push([n[0]+u[0]*d*.5,n[1]+u[1]*d*.5]),e.push(A);const z=[];z.push([h[0]-u[0]*p,h[1]-u[1]*p]),z.push([h[0]+u[0]*d*.375,h[1]+u[1]*d*.375]),(0,Z.qh)(z[z.length-1],1),z.push([h[0]+u[0]*d*.75,h[1]+u[1]*d*.75]),e.push(z),e.push([r,c]);break}case x.Em.ParallelWithTicks:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(c,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h),this._addAngledTicks(e,n,r,c),this._addAngledTicks(e,this._mix(n,1,h,u),this._mix(r,1,h,u),this._mid(n,r));break}case x.Em.Parallel:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._leftPerp(h),p=this._crossProduct(h,this._sub(c,n));let d=[n,r];e.push(d),d=[],d.push([n[0]+u[0]*p,n[1]+u[1]*p]),d.push([r[0]+u[0]*p,r[1]+u[1]*p]),e.push(d);break}case x.Em.PerpendicularToFirstSegment:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._mid(n,r),u=this._sub(r,n);this._normalize(u);const p=this._crossProduct(u,this._sub(c,n));this._leftPerpendicular(u);const d=[];d.push([h[0]-u[0]*p*.25,h[1]-u[1]*p*.25]),d.push([h[0]+u[0]*p*1.25,h[1]+u[1]*p*1.25]),e.push(d);break}case x.Em.ParallelOffset:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]-h[0]*u,n[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);const d=[];d.push([n[0]+h[0]*u,n[1]+h[1]*u]),d.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(d);break}case x.Em.OffsetOpposite:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]-h[0]*u,n[1]-h[1]*u]),p.push([r[0]-h[0]*u,r[1]-h[1]*u]),e.push(p);break}case x.Em.OffsetSame:{const r=this._cp2(i,3,0),c=this._cp3(i,r,.5,-1),h=this._sub(r,n);this._normalize(h);const u=this._crossProduct(h,this._sub(c,n));this._leftPerpendicular(h);const p=[];p.push([n[0]+h[0]*u,n[1]+h[1]*u]),p.push([r[0]+h[0]*u,r[1]+h[1]*u]),e.push(p);break}case x.Em.CircleWithArc:{let r=this._cp2(i,3,0);const c=this._cp3(i,r,.5,-1);let h,u;if(a>=4)h=i[3],u=this._crossProduct(this._sub(h,r),this._sub(c,r))>0;else{h=r,u=this._crossProduct(this._sub(h,n),this._sub(c,n))>0;const G=24*this._geomUnitsPerPoint,B=this._sub(h,n);this._normalize(B,G);const q=Math.sqrt(2)/2;this._rotateDirect(B,q,u?q:-q),r=this._add(n,B)}const p=this._sub(r,n),d=Math.cos(Math.PI/18),A=Math.sin(Math.PI/18),z=[r];for(let G=1;G<=36;G++)this._rotateDirect(p,d,A),z.push(this._add(n,p));this._add90DegArc(z,r,h,c,u),(0,Z.qh)(z[z.length-8],1),e.push(z);break}case x.Em.DoubleJog:{let r,c,h=this._cp2(i,-3,1);if(r=a>=3?i[2]:this._add(n,this._sub(n,h)),a>=4)c=i[3];else{const At=n;n=h,c=r;const kt=this._dist(n,At),vt=this._dist(c,At);let yt=30*this._geomUnitsPerPoint;.5*kt<yt&&(yt=.5*kt),.5*vt<yt&&(yt=.5*vt),h=this._mix(n,yt/kt,At,(kt-yt)/kt),r=this._mix(c,yt/vt,At,(vt-yt)/vt)}const u=this._mid(n,h),p=this._mid(c,r),d=this._dist(n,h),A=this._dist(r,c);let z=Math.min(d,A)/8;z=Math.min(z,24*this._geomUnitsPerPoint);const G=Math.cos(Math.PI/4);let B=this._sub(n,h);this._normalize(B,z),this._crossProduct(B,this._sub(c,h))>0?this._rotateDirect(B,G,-G):this._rotateDirect(B,G,G);let q=[];q.push(h),q.push(this._add(u,B)),q.push(this._sub(u,B)),q.push(n),e.push(q),B=this._sub(c,r),this._normalize(B,z),this._crossProduct(B,this._sub(n,r))<0?this._rotateDirect(B,G,G):this._rotateDirect(B,G,-G),q=[],q.push(r),q.push(this._add(p,B)),q.push(this._sub(p,B)),q.push(c),e.push(q);break}case x.Em.PerpendicularOffset:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(n,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u);e.push([p,n]);break}case x.Em.LineExcludingLastSegment:{const r=this._arrowPath(i),c=[];let h=r.length-2;for(;h--;)c.push(r[h]);e.push(c);break}case x.Em.MultivertexArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!1),e.push(c);break}case x.Em.CrossedArrow:{const r=this._arrowPath(i),c=[];this._addArrow(c,r,!0),e.push(c);break}case x.Em.ChevronArrow:{const[r,c]=this._arrowLastSeg(i),h=10*this._geomUnitsPerPoint,u=this._sub(n,r);this._normalize(u);const p=this._crossProduct(u,this._sub(c,r)),d=this._leftPerp(u),A=[c[0]-d[0]*p*2,c[1]-d[1]*p*2],z=[];z.push([c[0]+u[0]*h,c[1]+u[1]*h]),z.push(n),z.push([A[0]+u[0]*h,A[1]+u[1]*h]),e.push(z);break}case x.Em.ChevronArrowOffset:{const[r,c]=this._arrowLastSeg(i),h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h);const p=[c[0]-h[0]*u,c[1]-h[1]*u],d=[];d.push([p[0]+h[0]*u*.5,p[1]+h[1]*u*.5]),d.push(this._mid(p,n)),d.push([p[0]-h[0]*u*.5,p[1]-h[1]*u*.5]),e.push(d);break}case x.Em.PartialFirstSegment:{const[r,c]=this._arrowLastSeg(i),h=this._sub(n,r);this._normalize(h);const u=this._crossProduct(h,this._sub(c,r));this._leftPerpendicular(h),e.push([r,[c[0]-h[0]*u,c[1]-h[1]*u]]);break}case x.Em.Arch:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=this._sub(n,r),u=this._mix(c,1,h,.55),p=this._mix(c,1,h,-.55),d=[n];this._addBezier2(d,n,u,c,4),this._addBezier2(d,c,p,r,4),e.push(d);break}case x.Em.CurvedParallelTicks:{const r=this._cp2(i,-4,1),c=this._cp3(i,r,.882353,-1.94),h=this._sub(c,r);this._crossProduct(h,this._sub(n,r))>0?this._rightPerpendicular(h):this._leftPerpendicular(h);const u=[h[0]/8,h[1]/8],p=this._sub(this._mid(r,c),u),d=this._sub(this._mix(r,.75,c,.25),u),A=this._sub(this._mix(r,.25,c,.75),u),z=[r];this._addBezier2(z,r,d,p,3),this._addBezier2(z,p,A,c,3),e.push(z);for(let G=0;G<8;G++){const B=z[2*G+1],q=[this._clone(B)];q.push(this._add(B,[h[0]/4,h[1]/4])),e.push(q)}break}case x.Em.Arc90Degrees:{const r=this._cp2(i,0,-1),c=this._cp3(i,r,.5,1),h=[r];this._add90DegArc(h,r,n,c),e.push(h);break}default:e.push(i)}}return e}}let Et=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new zt(e,i,a)}}return f.instance=null,f})();class zt extends Z.zY{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new F,this._beginCut=(void 0!==e.beginCut?e.beginCut:1)*i,this._endCut=(void 0!==e.endCut?e.endCut:1)*i,this._middleCut=(void 0!==e.middleCut?e.middleCut:0)*i,this._invert=void 0!==e.invert&&e.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(s){const e=this._beginCut,i=this._endCut,a=this._middleCut,n=this._curveHelper.calculatePathLength(s),r=[];if(this._invert){if(0!==e||0!==i||0!==a)if(e+i+a>=n)r.push(s);else{let c=this._curveHelper.getSubCurve(s,0,e);c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(n-a),.5*(n+a)),c&&r.push(c),c=this._curveHelper.getSubCurve(s,n-i,i),c&&r.push(c)}}else if(0===e&&0===i&&0===a)r.push(s);else if(!(e+i+a>=n))if(0===a){const c=this._curveHelper.getSubCurve(s,e,n-i);c&&r.push(c)}else{let c=this._curveHelper.getSubCurve(s,e,.5*(n-a));c&&r.push(c),c=this._curveHelper.getSubCurve(s,.5*(n+a),n-i),c&&r.push(c)}return 0===r.length?null:{paths:r}}}class ot{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(s,e,i=!0){if(this._setEmpty(),!s||0===s.length)return!1;for(let a=0;a<s.length;a++){let n=Math.abs(s[a]);i&&n<1e-7&&(n=1e-7),this._values.push(n),this._length+=n}return e&&1&s.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(s){const e=this._values?this._values.length:0;for(let i=0;i<e;++i)this._values[i]*=s;this._length*=s,this.extPtGap*=s,this.ctrlPtGap*=s}addValue(s){this._length+=s,this._values.push(s)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}var w,f;(f=w||(w={}))[f.FAIL=0]="FAIL",f[f.END=1]="END",f[f.CONTINUE=2]="CONTINUE";class V{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(s){s.segment=this.segment,s.segmentLength=this.segmentLength,s.abscissa=this.abscissa,s.isPathEnd=this.isPathEnd,s.isPartEnd=this.isPartEnd}}class Q extends F{constructor(s=0,e=!1){super(s,e),this._tolerance=wt,this._currentPosition=new V}updateTolerance(s){this._tolerance=wt*s}init(s,e,i=!0){return i?(this._patternLength=e.length(),this._partExtPtGap=e.extPtGap,this._partCtrlPtGap=e.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=s,this._seg=-1,this._setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(s,e=w.FAIL){const i=new V;return!!this._nextPosition(s,i,null,e)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(s){s.pt=this._getPoint(this._currentPosition);const[e,i]=this._getAngle(this._currentPosition);s.ca=e,s.sa=i}nextPointAndAngle(s,e,i=w.FAIL){const a=new V;if(!this._nextPosition(s,a,null,i))return!1;a.copyTo(this._currentPosition),e.pt=this._getPoint(a);const[n,r]=this._getAngle(a);return e.ca=n,e.sa=r,!0}nextCurve(s){if(0===s)return null;const e=[],i=new V;return this._nextPosition(s,i,e,w.END)?(i.copyTo(this._currentPosition),e):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(s,e,i,a){if(this._currentPosition.isPathEnd)return!1;let n=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(n/=this._currentPosition.segmentLength),this._currentPosition.copyTo(e);e.abscissa+s*this._partLengthRatio>e.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===n){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,n));const r=this._path[e.segment+1];i.push([r[0],r[1]])}if(n=0,s-=(e.segmentLength-e.abscissa)/this._partLengthRatio,this._partSegCount)e.segment=this._nextSegment(),e.segmentLength=this.calculateSegLength(this._path,e.segment),e.abscissa=0,this._partSegCount--;else{if(!this._setPosAtNextPart())return a!==w.FAIL&&(e.segmentLength=this.calculateSegLength(this._path,e.segment),e.isPartEnd=!0,a===w.END?(e.abscissa=e.segmentLength,e.isPathEnd=!0):e.abscissa=e.segmentLength+s,!0);this._currentPosition.copyTo(e)}}if(e.abscissa+=s*this._partLengthRatio,i){if(0===i.length)if(0===n){const c=this._path[e.segment];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,n));const r=e.abscissa/e.segmentLength;if(1===r){const c=this._path[e.segment+1];i.push([c[0],c[1]])}else i.push(this.getSegCoord2D(this._path,e.segment,r))}return this._partSegCount||Math.abs(e.abscissa-e.segmentLength)<this._tolerance&&(e.isPathEnd=this._partIsLast,e.isPartEnd=!0),!0}_getPoint(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_getAngle(s){if(-1===s.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,s.segment,s.segmentLength<=0?0:s.abscissa/s.segmentLength)}_setPosAtNextPart(){for(;this._partSegCount;)this._hasNextSegment()&&this._nextSegment(),this._partSegCount--;if(!this._hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this._hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this._nextSegment()),this._partSegCount++,1===(0,Z.zv)(this._path[this._getEndPointIndex()])){this._partIsLast=!this._hasNextSegment();break}let s=this._partSegCount;for(;s;)this._previousSegment(),--s;this._currentPosition.segment=this._nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const e=this._getStartPointIndex();this._ctrlPtBegin=1===(0,Z.zv)(this._path[e]);let i=e+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===(0,Z.zv)(this._path[i]),this._patternLength>0){const a=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,n=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let r=Math.round((this._partLength-(a+n))/this._patternLength);r<=0&&(r=a+n>0?0:1),this._partLengthRatio=this._partLength/(a+n+r*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}_hasNextSegment(){return this._seg<this._path.length-2}_previousSegment(){return--this._seg}_nextSegment(){return++this._seg}_getStartPointIndex(){return this._seg}_getEndPointIndex(){return this._seg+1}}let E=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new D(e,i,a)}}return f.instance=null,f})();class D extends Z.zY{constructor(s,e,i){var a,n;super(s,!0,!0),this._walker=new Q,this._walker.updateTolerance(i),this._endings=e.lineDashEnding,this._customDashPos=-(null!=(a=e.offsetAlongLine)?a:0)*i,this._offsetAtEnd=(null!=(n=e.customEndingOffset)?n:0)*i,this._pattern=new ot,this._pattern.init(e.dashTemplate,!0),this._pattern.scale(i)}processPath(s){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[s]};if(!this.iteratePath){let a=!0;switch(this._endings){case x.sj.HalfPattern:case x.sj.HalfGap:default:this._pattern.extPtGap=0;break;case x.sj.FullPattern:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case x.sj.FullGap:this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case x.sj.NoConstraint:this.isClosed||(a=!1);break;case x.sj.Custom:this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const n=this._walker.calculatePathLength(s);if(this._pattern.isEmpty()||n<.1*this._pattern.length())return{paths:[s]};if(!this._walker.init(s,this._pattern,a))return{paths:[s]}}let e;if(this.iteratePath)e=this._pattern.nextValue();else{let a;switch(this._endings){case x.sj.HalfPattern:default:a=.5*this._pattern.firstValue();break;case x.sj.HalfGap:a=.5*-this._pattern.lastValue();break;case x.sj.FullGap:a=-this._pattern.lastValue();break;case x.sj.FullPattern:a=0;break;case x.sj.NoConstraint:case x.sj.Custom:a=-this._customDashPos}let n=a/this._pattern.length();n-=Math.floor(n),a=n*this._pattern.length(),this._pattern.reset(),e=this._pattern.nextValue();let r=!1;for(;a>=e;)a-=e,e=this._pattern.nextValue(),r=!r;e-=a,r?(this._walker.nextPosition(e),e=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(e),e=this._pattern.nextValue(),this._walker.nextPosition(e),e=this._pattern.nextValue())}let i=this._walker.nextCurve(e);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),T.mergePath(i,this._firstCurve),this._firstCurve=null)):(e=this._pattern.nextValue(),!this._walker.nextPosition(e)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}let U=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new j(e,i,a)}}return f.instance=null,f})();class j{constructor(s,e,i){switch(this._inputGeometries=s,this._curveHelper=new F,this._width=(void 0!==e.width?e.width:2)*i,e.method){case x.$y.Mitered:default:this._method=x.id.Mitered;break;case x.$y.Bevelled:this._method=x.id.Bevelled;break;case x.$y.Rounded:case x.$y.TrueBuffer:this._method=x.id.Rounded;break;case x.$y.Square:this._method=x.id.Square}this._option=e.option,this._offsetFlattenError=wt*i}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s)&&this._width>0){if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)-2*this._width<0)return s;const e=[];return e.push([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]),e.push([[s.xmin+this._width,s.ymin+this._width],[s.xmax-this._width,s.ymin+this._width],[s.xmax-this._width,s.ymax-this._width],[s.xmin+this._width,s.ymax-this._width],[s.xmin+this._width,s.ymin+this._width]]),{rings:e}}if((0,W.oU)(s)&&this._width>0){const e=[];for(const i of s.rings){const a=this._curveHelper.calculatePathLength(i),n=this._curveHelper.offset(i,this._width,this._method,4,this._offsetFlattenError);n&&(a<0&&n.reverse(),e.push(n))}if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}}let st=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new X(e,i,a)}}return f.instance=null,f})();class X extends Z.zY{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new F,this._length=(void 0!==e.length?e.length:20)*i,this._angle=void 0!==e.angle?e.angle:225,this._position=void 0!==e.position?e.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(s){if(this._curveHelper.isEmpty(s,!1))return null;const e=s[0],i=s[s.length-1];this._curveHelper.normalize([i[0]-e[0],i[1]-e[1]]);const n=[e[0]+(i[0]-e[0])*this._position/100,e[1]+(i[1]-e[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let c=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(c=-c),this._mirror=!this._mirror,{paths:[[e,[n[0]-this._length/2*r,n[1]-this._length/2*c],[n[0]+this._length/2*r,n[1]+this._length/2*c],i]]}}}let o=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new _(e,i,a)}}return f.instance=null,f})();class _{constructor(s,e,i){this._inputGeometries=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?-e.offsetY*i:0}next(){let s=this._inputGeometries.next();for(;s;){if((0,W.YX)(s))return{xmin:s.xmin+this._offsetX,xmax:s.xmax+this._offsetX,ymin:s.ymin+this._offsetY,ymax:s.ymax+this._offsetY};if((0,W.oU)(s)){const e=(0,ut.d9)(s);return this._moveMultipath(e.rings,this._offsetX,this._offsetY),e}if((0,W.l9)(s)){const e=(0,ut.d9)(s);return this._moveMultipath(e.paths,this._offsetX,this._offsetY),e}if((0,W.aW)(s)){const e=(0,ut.d9)(s);return this._movePath(e.points,this._offsetX,this._offsetY),e}if((0,W.wp)(s))return{x:s.x+this._offsetX,y:s.y+this._offsetY};s=this._inputGeometries.next()}return null}_moveMultipath(s,e,i){if(s)for(const a of s)this._movePath(a,e,i)}_movePath(s,e,i){if(s)for(const a of s)a[0]+=e,a[1]+=i}}let M=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new y(e,i,a)}}return f.instance=null,f})();class y{constructor(s,e,i){var a;this._inputGeometries=s,this._curveHelper=new F,this._offset=(null!=(a=e.offset)?a:1)*i,this._method=e.method,this._option=e.option,this._offsetFlattenError=wt*i}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._offset)return s;if((0,W.YX)(s)){if(this._method===x.id.Rounded&&this._offset>0){const i=this._curveHelper.offset([[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]],-this._offset,this._method,4,this._offsetFlattenError);return i?{rings:[i]}:null}if(Math.min(s.xmax-s.xmin,s.ymax-s.ymin)+2*this._offset>0)return{xmin:s.xmin-this._offset,xmax:s.xmax+this._offset,ymin:s.ymin-this._offset,ymax:s.ymax+this._offset}}if((0,W.oU)(s)){const e=[];for(const i of s.rings){const a=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);a&&e.push(a)}if(e.length)return{rings:e}}if((0,W.l9)(s)){const e=[];for(const i of s.paths){const a=this._curveHelper.offset(i,-this._offset,this._method,4,this._offsetFlattenError);a&&e.push(a)}if(e.length)return{paths:e}}s=this._inputGeometries.next()}return null}}let I=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new O(e,i,a)}}return f.instance=null,f})();class O{constructor(s,e,i){this._inputGeometries=s,this._reverse=void 0===e.reverse||e.reverse}next(){let s=this._inputGeometries.next();for(;s;){if(!this._reverse)return s;if((0,W.l9)(s)){const e=(0,ut.d9)(s);return(0,Z.ov)(e.paths),e}s=this._inputGeometries.next()}return null}}var k=R(65401),$=R(32442);let tt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new lt(e,i,a)}}return f.instance=null,f})();class lt{constructor(s,e,i){this._inputGeometries=s,this._rotateAngle=void 0!==e.angle?e.angle*Math.PI/180:0}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._rotateAngle)return s;const e=(0,k.Ue)();(0,$.$P)(e,s);const i=(e[2]+e[0])/2,a=(e[3]+e[1])/2;if((0,W.YX)(s)){const n={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._rotateMultipath(n.rings,i,a),n}if((0,W.oU)(s)){const n=(0,ut.d9)(s);return this._rotateMultipath(n.rings,i,a),n}if((0,W.l9)(s)){const n=(0,ut.d9)(s);return this._rotateMultipath(n.paths,i,a),n}if((0,W.aW)(s)){const n=(0,ut.d9)(s);return this._rotatePath(n.points,i,a),n}if((0,W.wp)(s))return s;s=this._inputGeometries.next()}return null}_rotateMultipath(s,e,i){if(s)for(const a of s)this._rotatePath(a,e,i)}_rotatePath(s,e,i){if(s){const a=Math.cos(this._rotateAngle),n=Math.sin(this._rotateAngle);for(const r of s){const c=r[0]-e,h=r[1]-i;r[0]=e+c*a-h*n,r[1]=i+c*n+h*a}}}}let ct=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new _t(e,i,a)}}return f.instance=null,f})();class _t{constructor(s,e,i){this._inputGeometries=s,this._xFactor=void 0!==e.xScaleFactor?e.xScaleFactor:1.15,this._yFactor=void 0!==e.yScaleFactor?e.yScaleFactor:1.15}next(){let s=this._inputGeometries.next();for(;s;){if(1===this._xFactor&&1===this._yFactor)return s;const e=(0,k.Ue)();(0,$.$P)(e,s);const i=(e[2]+e[0])/2,a=(e[3]+e[1])/2;if((0,W.YX)(s)){const n={rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]};return this._scaleMultipath(n.rings,i,a),n}if((0,W.oU)(s)){const n=(0,ut.d9)(s);return this._scaleMultipath(n.rings,i,a),n}if((0,W.l9)(s)){const n=(0,ut.d9)(s);return this._scaleMultipath(n.paths,i,a),n}if((0,W.aW)(s)){const n=(0,ut.d9)(s);return this._scalePath(n.points,i,a),n}if((0,W.wp)(s))return s;s=this._inputGeometries.next()}return null}_scaleMultipath(s,e,i){if(s)for(const a of s)this._scalePath(a,e,i)}_scalePath(s,e,i){if(s)for(const a of s){const r=(a[1]-i)*this._yFactor;a[0]=e+(a[0]-e)*this._xFactor,a[1]=i+r}}}let Pt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new Mt(e,i,a)}}return f.instance=null,f})();class Mt{constructor(s,e,i){this._inputGeometries=s,this._height=(void 0!==e.amplitude?e.amplitude:2)*i,this._period=(void 0!==e.period?e.period:3)*i,this._style=e.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new ot,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new Q,this._walker.updateTolerance(i)}next(){let s=this._inputGeometries.next();for(;s;){if(0===this._height||0===this._period)return s;if((0,W.l9)(s)){const e=this._processGeom(s.paths);if(e.length)return{paths:e}}if((0,W.oU)(s)){const e=this._processGeom(s.rings);if(e.length)return{rings:e}}s=this._inputGeometries.next()}return null}_processGeom(s){const e=[];for(const i of s)if(this._walker.init(i,this._pattern))switch(this._style){case x.zQ.Sinus:default:e.push(this._constructCurve(i,!1));break;case x.zQ.Square:e.push(this._constructSquare(i));break;case x.zQ.Triangle:e.push(this._constructTriangle(i));break;case x.zQ.Random:e.push(this._constructCurve(i,!0))}else e.push(i);return e}_constructCurve(s,e){const i=new T,a=this._walker.calculatePathLength(s);let n=Math.round(a/this._period);0===n&&(n=1);const h=this._period/16,u=1/(16*n+1),p=2*Math.PI*a/(a/n),d=2*Math.PI*Math.random(),A=2*Math.PI*Math.random(),z=2*Math.PI*Math.random(),G=.75-Math.random()/2,B=.75-Math.random()/2,q={};this._walker.curPointAndAngle(q),i.startPath(q.pt);let At=0;for(;;){if(!this._walker.nextPointAndAngle(h,q)){i.lineTo(s[s.length-1]);break}{const kt=At;let vt;if(At+=u,e){const yt=this._height/2*(1+.3*Math.sin(G*p*kt+d));vt=yt*Math.sin(p*kt+A),vt+=yt*Math.sin(B*p*kt+z),vt/=2}else vt=.5*this._height*Math.sin(.5*p*kt);i.lineTo([q.pt[0]-vt*q.sa,q.pt[1]+vt*q.ca])}}return i.path()}_constructSquare(s){const e=new T,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let a=!0;for(;;){let n=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(a?(e.startPath(r.pt),a=!1):e.lineTo(r.pt),e.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([c.pt[0]+this._height/2*c.sa,c.pt[1]-this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca]),n=!0)}}if(!n){e.lineTo(this._walker.getPathEnd());break}}return e.path()}_constructTriangle(s){const e=new T,i=this._walker.calculatePathLength(s);Math.round(i/this._period);let a=!0;for(;;){let n=!1;if(this._walker.curPositionIsValid()){const r={};this._walker.curPointAndAngle(r);const c={};if(this._walker.nextPointAndAngle(this._period/2,c)){const h={};this._walker.nextPointAndAngle(this._period,h)&&(this._walker.nextPosition(this._period/2)&&(a?(e.startPath(r.pt),a=!1):e.lineTo(r.pt),e.lineTo([c.pt[0]-this._height/2*c.sa,c.pt[1]+this._height/2*c.ca]),e.lineTo([h.pt[0]+this._height/2*h.sa,h.pt[1]-this._height/2*h.ca])),n=!0)}}if(!n){e.lineTo(this._walker.getPathEnd());break}}return e.path()}}let L=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new l(e,i,a)}}return f.instance=null,f})();class l extends Z.v1{constructor(s,e,i){var a;super(s,!0,!0),this._geometryWalker=new Q,this._geometryWalker.updateTolerance(i),this._angleToLine=null==(a=e.angleToLine)||a,this._offset=(e.offset?e.offset:0)*i,this._originalEndings=e.endings,this._offsetAtEnd=(e.customEndingOffset?e.customEndingOffset:0)*i,this._position=-(e.offsetAlongLine?e.offsetAlongLine:0)*i,this._pattern=new ot,this._pattern.init(e.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath)e=this._pattern.nextValue();else{this._endings=this._originalEndings===x.JS.WithFullGap&&this.isClosed?x.JS.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let a,n=!0;switch(this._endings){case x.JS.NoConstraint:a=-this._position,a=this._adjustPosition(a),n=!1;break;case x.JS.WithHalfGap:default:a=-this._pattern.lastValue()/2;break;case x.JS.WithFullGap:a=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case x.JS.WithMarkers:a=0;break;case x.JS.Custom:a=-this._position,a=this._adjustPosition(a),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._geometryWalker.init(s,this._pattern,n))return null;this._pattern.reset();let r=0;for(;a>r;)a-=r,r=this._pattern.nextValue();r-=a,e=r,this.iteratePath=!0}const i={};return this._geometryWalker.nextPointAndAngle(e,i)?this._endings===x.JS.WithFullGap&&this._geometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===x.JS.WithMarkers&&this._geometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(s){let e=s/this._pattern.length();return e-=Math.floor(e),e*this._pattern.length()}}let m=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new g(e,i,a)}}return f.instance=null,f})();class g extends Z.v1{constructor(s,e,i){super(s,!1,!0),this._curveHelper=new F,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._type=e.extremityPlacement,this._position=void 0!==e.offsetAlongLine?e.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(s){let e;switch(this._type){case x.Tx.Both:default:this._beginProcessed?(e=this._atExtremities(s,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(e=this._atExtremities(s,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case x.Tx.JustBegin:e=this._atExtremities(s,this._position,!0);break;case x.Tx.JustEnd:e=this._atExtremities(s,this._position,!1);case x.Tx.None:}return e}_atExtremities(s,e,i){const a=s.length;if(a<2)return null;const r=i?a:-1,c=i?1:-1;let h,u=0,p=i?s[0]:s[a-1];for(let d=i?1:a-2;d!==r;d+=c){h=p,p=s[d];const A=this._curveHelper.calculateLength(h,p);if(u+A>e){const z=(e-u)/A,[G,B]=this._curveHelper.getAngleCS(h,p,z),q=(0,Z.XV)(h,p,z);return this.internalPlacement.setTranslate(q[0]-this._offset*B,q[1]+this._offset*G),this._angleToLine&&this.internalPlacement.setRotateCS(-G,-B),this.internalPlacement}u+=A}return null}}let b=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new S(e,i,a)}}return f.instance=null,f})();class S extends Z.v1{constructor(s,e,i){super(s,!0,!0),this._walker=new Q,this._walker.updateTolerance(i),this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._beginGap=void 0!==e.beginPosition?e.beginPosition*i:0,this._endGap=void 0!==e.endPosition?e.endPosition*i:0,this._flipFirst=void 0===e.flipFirst||e.flipFirst,this._pattern=new ot,this._pattern.init(e.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(s){if(this._pattern.isEmpty())return null;let e;if(this.iteratePath){const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(s)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(s,this._pattern,!1))return null;this._pattern.reset();const c=this._pattern.nextValue()*this._subPathLen,h=this._beginGap+c;e=h-this._prevPos,this._prevPos=h,this.iteratePath=!0}const i={};if(!this._walker.nextPointAndAngle(e,i,w.END))return this.iteratePath=!1,null;let n,r;return this.internalPlacement.setTranslate(i.pt[0]-this._offset*i.sa,i.pt[1]+this._offset*i.ca),this._angleToLine?(n=i.ca,r=i.sa):(n=1,r=0),this._isFirst&&this._flipFirst&&(n=-n,r=-r),this.internalPlacement.setRotateCS(n,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}var P=R(97373);let C=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new H(e,i,a,n)}}return f.instance=null,f})();class H{constructor(s,e,i,a){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=(void 0!==e.stepX?Math.abs(e.stepX):16)*i,this._stepY=(void 0!==e.stepY?Math.abs(e.stepY):16)*i,0!==this._stepX&&0!==this._stepY&&s&&function v(f){return void 0!==f.rings}(s)&&s.rings){if(this._gridType=void 0!==e.gridType?e.gridType:x.bj.Fixed,this._gridType===x.bj.Random)this._randomness=void 0!==e.randomness?e.randomness/100:1,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=void 0!==e.gridAngle?e.gridAngle:0,this._shiftOddRows=void 0!==e.shiftOddRows&&e.shiftOddRows,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new P.u,this._calculateMinMax(s),this._geometry=s}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(s){let e,i,a,n,r,c,h,u;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,r=c=Number.MAX_VALUE,h=u=-Number.MAX_VALUE;for(const p of s.rings){const d=p?p.length:0;for(let A=0;A<d;++A)e=p[A][0]-this._graphicOriginX-this._offsetX,i=p[A][1]-this._graphicOriginY-this._offsetY,a=this._cosAngle*e-this._sinAngle*i,n=this._sinAngle*e+this._cosAngle*i,r=Math.min(r,a),h=Math.max(h,a),c=Math.min(c,n),u=Math.max(u,n)}r+=this._graphicOriginX,h+=this._graphicOriginX,c+=this._graphicOriginY,u+=this._graphicOriginY,this._xMin=Math.round(r/this._stepX),this._xMax=Math.round(h/this._stepX),this._yMin=Math.round(c/this._stepY),this._yMax=Math.round(u/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let s=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(s+=.5*this._stepX);const e=this._currentY*this._stepY+this._offsetY;let i,a;return this._currentX++,this._gridType===x.bj.Random?(i=this._graphicOriginX+s+this._stepX*this._randomness*(.5-Math.random())*2/3,a=this._graphicOriginY+e+this._stepY*this._randomness*(.5-Math.random())*2/3):(i=this._graphicOriginX+this._cosAngle*s+this._sinAngle*e,a=this._graphicOriginY-this._sinAngle*s+this._cosAngle*e),this._internalPlacement.setTranslate(i,a),this._internalPlacement}}}let it=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new pt(e,i,a)}}return f.instance=null,f})();class pt extends Z.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new F,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._relativeTo=e.relativeTo,this._position=void 0!==e.startPointOffset?e.startPointOffset*i:0,this._epsilon=.001*i}processPath(s){const e=this._position;if(this._relativeTo===x.CS.SegmentMidpoint){for(this.iteratePath||(this._segmentCount=s.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const a=this._curSegment;this._curSegment++;const n=s[a-1],r=s[a],c=this._curveHelper.calculateLength(n,r);if(c<this._epsilon)continue;const h=.5+this._position/c,[u,p]=this._curveHelper.getAngleCS(n,r,h),d=(0,Z.XV)(n,r,h);return this.internalPlacement.setTranslate(d[0]-this._offset*p,d[1]+this._offset*u),this._angleToLine&&this.internalPlacement.setRotateCS(u,p),this.internalPlacement}return this.iteratePath=!1,null}this._relativeTo===x.CS.LineEnd&&(0,Z.hh)(s);const i=this.onLine(s,e);return this._relativeTo===x.CS.LineEnd&&(0,Z.hh)(s),i}onLine(s,e){let i,a=!1;switch(this._relativeTo){case x.CS.LineMiddle:default:i=this._curveHelper.calculatePathLength(s)/2+e;break;case x.CS.LineBeginning:i=e;break;case x.CS.LineEnd:i=e,a=!0}const n=s.length;let r,c=0,h=s[0];for(let u=1;u<n;++u){r=h,h=s[u];const p=this._curveHelper.calculateLength(r,h);if(c+p>i){const d=(i-c)/p,[A,z]=this._curveHelper.getAngleCS(r,h,d),G=(0,Z.XV)(r,h,d),B=a?-this._offset:this._offset;return this.internalPlacement.setTranslate(G[0]-B*z,G[1]+B*A),this._angleToLine&&(a?this.internalPlacement.setRotateCS(-A,-z):this.internalPlacement.setRotateCS(A,z)),this.internalPlacement}c+=p}return null}}let at=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new nt(e,i,a)}}return f.instance=null,f})();class nt extends Z.v1{constructor(s,e,i){super(s,!0,!0),this._curveHelper=new F,this._angleToLine=void 0===e.angleToLine||e.angleToLine,this._offset=void 0!==e.offset?e.offset*i:0,this._endPoints=void 0===e.placeOnEndPoints||e.placeOnEndPoints,this._controlPoints=void 0===e.placeOnControlPoints||e.placeOnControlPoints,this._regularVertices=void 0===e.placeOnRegularVertices||e.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(s){if(this.iteratePath||(this._preparePath(s),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const e=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(e[2]);let i=e[0],a=e[1];if(0!==this._offset){const n=Math.cos(e[2]),r=Math.sin(e[2]);i-=this._offset*r,a+=this._offset*n}return this.internalPlacement.setTranslate(i,a),this._tagIterator++,this.internalPlacement}_preparePath(s){this._tags.length=0,this._tagIterator=0;const e=(0,Z.QK)(s),i=s.length-1;let a,n,r=0,c=0,h=0,u=0,p=0;for(;r<i;){r++,a=s[r-1],n=s[r];const d=(0,Z.zv)(a),A=(0,Z.zv)(n);(this._angleToLine||0!==this._offset)&&(u=this._curveHelper.getAngle(a,n,0)),1===r?e?(c=u,h=d):(this._endPoints||this._controlPoints&&1===d)&&this._tags.push([a[0],a[1],u]):1===d?this._controlPoints&&this._tags.push([a[0],a[1],ft(p,u)]):this._regularVertices&&this._tags.push([a[0],a[1],ft(p,u)]),(this._angleToLine||0!==this._offset)&&(p=this._curveHelper.getAngle(a,n,1)),r===i&&(e?1===A||1===h?this._controlPoints&&this._tags.push([n[0],n[1],ft(p,c)]):this._regularVertices&&this._tags.push([n[0],n[1],ft(p,c)]):(this._endPoints||this._controlPoints&&1===A)&&this._tags.push([n[0],n[1],p]))}this._tagIterator=0}}function ft(f,s){const e=Math.PI;for(;Math.abs(s-f)>e+2e-15;)s-f>e?s-=2*e:s+=2*e;return(f+s)/2}let xt=(()=>{class f{static local(){return null===f.instance&&(f.instance=new f),f.instance}execute(e,i,a,n){return new Dt(e,i,a)}}return f.instance=null,f})();class Dt{constructor(s,e,i){this._geometry=s,this._offsetX=void 0!==e.offsetX?e.offsetX*i:0,this._offsetY=void 0!==e.offsetY?e.offsetY*i:0,this._method=void 0!==e.method?e.method:x.Lh.OnPolygon,this._internalPlacement=new P.u}next(){const s=this._geometry;return this._geometry=null,s&&function It(f){return void 0!==f.rings}(s)?this._polygonCenter(s):null}_polygonCenter(s){let e=!1;switch(this._method){default:{const i=(0,k.Ue)();(0,$.$P)(i,s),this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2+this._offsetY),e=!0;break}}return e?this._internalPlacement:null}}function Ft(f){if(!f)return null;switch(f.type){case"CIMGeometricEffectAddControlPoints":return ht.local();case"CIMGeometricEffectArrow":return J.local();case"CIMGeometricEffectBuffer":return mt.local();case"CIMGeometricEffectControlMeasureLine":return Ct.local();case"CIMGeometricEffectCut":return Et.local();case"CIMGeometricEffectDashes":return E.local();case"CIMGeometricEffectDonut":return U.local();case"CIMGeometricEffectJog":return st.local();case"CIMGeometricEffectMove":return o.local();case"CIMGeometricEffectOffset":return M.local();case"CIMGeometricEffectReverse":return I.local();case"CIMGeometricEffectRotate":return tt.local();case"CIMGeometricEffectScale":return ct.local();case"CIMGeometricEffectWave":return Pt.local()}return null}function Ot(f){if(!f)return null;switch(f.type){case"CIMMarkerPlacementAlongLineSameSize":return L.local();case"CIMMarkerPlacementAtExtremities":return m.local();case"CIMMarkerPlacementAtRatioPositions":return b.local();case"CIMMarkerPlacementInsidePolygon":return C.local();case"CIMMarkerPlacementOnLine":return it.local();case"CIMMarkerPlacementOnVertices":return at.local();case"CIMMarkerPlacementPolygonCenter":return xt.local()}return null}},97373:(Tt,gt,R)=>{R.d(gt,{u:()=>ut});class ut{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(ht,St){this.tx=ht,this.ty=St}setTranslateZ(ht){this.tz=ht}setRotateCS(ht,St){this.rz=void 0,this.rz_c=ht,this.rz_s=St}setRotate(ht){this.rz=ht,this.rz_c=void 0,this.rz_s=void 0}setRotateY(ht){this.ry=ht}setScale(ht){this.s=ht}setMeasure(ht){this.m=ht}}},57052:(Tt,gt,R)=>{R.d(gt,{Z:()=>x});var ut=R(15861),W=R(84792),Z=R(26584),ht=R(10699);class x{constructor(){this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null}destroy(){this._inFlightResourceMap.clear(),this._resourceMap.clear()}getResource(F){var N;return null!=(N=this._resourceMap.get(F))?N:null}fetchResource(F,N){var K=this;return(0,ut.Z)(function*(){const rt={width:0,height:0},J=K._resourceMap,et=J.get(F);if(et)return rt.width=et.width,rt.height=et.height,rt;let mt=K._inFlightResourceMap.get(F);return mt||(mt=function wt(T,F){if(T.includes(";base64,")){const N=new Image;return N.src=T,N.decode().then(()=>({ok:!0,value:N})).catch(K=>(0,ht.D_)(K)?{ok:!1,error:K}:{ok:!1,error:new Z.Z("invalid-resource",`Could not fetch requested resource at ${T}`)})}return(0,W.default)(T,Ut({responseType:"image"},F)).then(N=>({ok:!0,value:N.data})).catch(N=>(0,ht.D_)(N)?{ok:!1,error:N}:{ok:!1,error:new Z.Z("invalid-resource",`Could not fetch requested resource at ${T}`)})}(F,N),K._inFlightResourceMap.set(F,mt),mt=mt.then(bt=>{if(K._inFlightResourceMap.delete(F),bt.ok){J.set(F,bt.value);const Ct=bt.value;return rt.width=Ct.width,rt.height=Ct.height,rt}return rt}),mt)})()}deleteResource(F){this._inFlightResourceMap.delete(F),this._resourceMap.delete(F)}}},89932:(Tt,gt,R)=>{R.d(gt,{cD:()=>E,uQ:()=>V,Tu:()=>Q,zA:()=>ot,x1:()=>U,et:()=>st,g:()=>j});var ut=R(986),W=R(63290),Z=R(62208),ht=R(27899),St=R(23841),x=R(65401),wt=R(32442),T=R(91179),F=R(29214),N=R(11004),K=R(97373),rt=R(57052),J=R(7547),et=R(31375),mt=R(68937),bt=R(61261),Ct=R(39351),Lt=R(25797);const Et=Math.PI/180,Rt=W.Z.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class ot{constructor(o){this._t=o}static createIdentity(){return new ot([1,0,0,0,1,0])}clone(){return new ot(this._t.slice())}transform(o){const _=this._t;return[_[0]*o[0]+_[1]*o[1]+_[2],_[3]*o[0]+_[4]*o[1]+_[5]]}static createScale(o,_){return new ot([o,0,0,0,_,0])}scale(o,_){const M=this._t;return M[0]*=o,M[1]*=o,M[2]*=o,M[3]*=_,M[4]*=_,M[5]*=_,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(o,_){return new ot([0,0,o,0,0,_])}translate(o,_){const M=this._t;return M[2]+=o,M[5]+=_,this}static createRotate(o){const _=Math.cos(o),M=Math.sin(o);return new ot([_,-M,0,M,_,0])}rotate(o){return ot.multiply(this,ot.createRotate(o),this)}static multiply(o,_,M){const y=o._t,I=_._t,k=y[1]*I[0]+y[4]*I[1],$=y[2]*I[0]+y[5]*I[1]+I[2],tt=y[0]*I[3]+y[3]*I[4],lt=y[1]*I[3]+y[4]*I[4],ct=y[2]*I[3]+y[5]*I[4]+I[5],_t=M._t;return _t[0]=y[0]*I[0]+y[3]*I[1],_t[1]=k,_t[2]=$,_t[3]=tt,_t[4]=lt,_t[5]=ct,M}invert(){const o=this._t;let _=o[0]*o[4]-o[1]*o[3];return 0===_?new ot([0,0,0,0,0,0]):(_=1/_,new ot([o[4]*_,-o[1]*_,(o[1]*o[5]-o[2]*o[4])*_,-o[3]*_,o[0]*_,(o[2]*o[3]-o[0]*o[5])*_]))}}class w{constructor(o,_){this._transfos=[],this._sizeTransfos=[],this._geomUnitsPerPoint=1,this._placementPool=new ht.Z(K.u,null,null,100),this._earlyReturn=!1,this._mapRotation=0,this._resourceManager=o||new rt.Z,this._transfos.push(_||ot.createIdentity()),this._sizeTransfos.push(_?_.scaleRatio():1)}setTransform(o,_){this._transfos=[o||ot.createIdentity()],this._sizeTransfos=[_||(o?o.scaleRatio():1)]}setGeomUnitsPerPoint(o){this._geomUnitsPerPoint=o}transformPt(o){return this._transfos[this._transfos.length-1].transform(o)}transformSize(o){return o*this._sizeTransfos[this._sizeTransfos.length-1]}reverseTransformPt(o){return this._transfos[this._transfos.length-1].invert().transform(o)}reverseTransformSize(o){return o/this._sizeTransfos[this._sizeTransfos.length-1]}geomUnitsPerPoint(){return this.isEmbedded()?1:this._geomUnitsPerPoint}isEmbedded(){return this._transfos.length>1}back(){return this._transfos[this._transfos.length-1]}push(o,_){const M=_?o.scaleRatio():1;ot.multiply(o,this.back(),o),this._transfos.push(o),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*M)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(o,_){if(o)switch(o.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(o,_);break;case"CIMTextSymbol":this.drawTextSymbol(o,_)}}drawMultiLayerSymbol(o,_){if(!o)return;const M=o.symbolLayers;if(!M)return;const y=o.effects;if(y&&y.length>0){const I=this.executeEffects(y,_);if(I){let O=I.next();for(;O;)this.drawSymbolLayers(M,O),O=I.next()}}else this.drawSymbolLayers(M,_)}executeEffects(o,_){const M=this._resourceManager.geometryEngine;let y=new F.M(_);for(const I of o){const O=(0,N.h)(I);O&&(y=O.execute(y,I,this.geomUnitsPerPoint(),M))}return y}drawSymbolLayers(o,_){let M=o.length;for(;M--;){const y=o[M];if(!y||!1===y.enable)continue;const I=y.effects;if(I&&I.length>0){const O=this.executeEffects(I,_);if(O){let k=null;for(;(k=O.next())&&(this.drawSymbolLayer(y,k),!this._earlyReturn););}}else this.drawSymbolLayer(y,_);if(this._earlyReturn)return}}drawSymbolLayer(o,_){switch(o.type){case"CIMSolidFill":this.drawSolidFill(_,o.color);break;case"CIMHatchFill":this.drawHatchFill(_,o);break;case"CIMPictureFill":this.drawPictureFill(_,o);break;case"CIMGradientFill":this.drawGradientFill(_,o);break;case"CIMSolidStroke":this.drawSolidStroke(_,o.color,o.width,o.capStyle,o.joinStyle,o.miterLimit);break;case"CIMPictureStroke":this.drawPictureStroke(_,o);break;case"CIMGradientStroke":this.drawGradientStroke(_,o);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(o,_)}}drawHatchFill(o,_){const M=this._buildHatchPolyline(_,o,this.geomUnitsPerPoint());M&&(this.pushClipPath(o),this.drawMultiLayerSymbol(_.lineSymbol,M),this.popClipPath())}drawPictureFill(o,_){}drawGradientFill(o,_){}drawPictureStroke(o,_){}drawGradientStroke(o,_){}drawMarkerLayer(o,_){const M=o.markerPlacement;if(M){const y=(0,N.W)(M);if(y){const I="CIMMarkerPlacementInsidePolygon"===M.type;I&&this.pushClipPath(_);const O=y.execute(_,M,this.geomUnitsPerPoint(),this._resourceManager.geometryEngine);if(O){let k=null;for(;(k=O.next())&&(this.drawMarker(o,k),!this._earlyReturn););}I&&this.popClipPath()}}else{const y=this._placementPool.acquire();if((0,T.wp)(_))y.tx=_.x,y.ty=_.y,this.drawMarker(o,y);else for(const I of _.points)if(y.tx=I[0],y.ty=I[1],this.drawMarker(o,y),this._earlyReturn)break;this._placementPool.release(y)}}drawMarker(o,_){switch(o.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(o,_);break;case"CIMVectorMarker":this.drawVectorMarker(o,_)}}drawPictureMarker(o,_){var M,y,I,O,k;if(!o)return;const $=this._resourceManager.getResource(o.url),tt=null!=(M=o.size)?M:10;if((0,Z.Wi)($)||tt<=0)return;const lt=$.width,ct=$.height;if(!lt||!ct)return;const _t=lt/ct,Pt=null!=(y=o.scaleX)?y:1,Mt=ot.createIdentity(),L=o.anchorPoint;if(L){let P=L.x,v=L.y;"Absolute"!==o.anchorPointUnits&&(P*=tt*_t*Pt,v*=tt),Mt.translate(-P,-v)}let l=null!=(I=o.rotation)?I:0;o.rotateClockwise&&(l=-l),this._mapRotation&&(l+=this._mapRotation),l&&Mt.rotate(l*Et);let m=null!=(O=o.offsetX)?O:0,g=null!=(k=o.offsetY)?k:0;if(m||g){if(this._mapRotation){const P=Et*this._mapRotation,v=Math.cos(P),C=Math.sin(P),H=m*C+g*v;m=m*v-g*C,g=H}Mt.translate(m,g)}const b=this.geomUnitsPerPoint();1!==b&&Mt.scale(b,b);const S=_.getAngle();S&&Mt.rotate(S),Mt.translate(_.tx,_.ty),this.push(Mt,!1),this.drawImage(o.url,tt,o.scaleX),this.pop()}drawVectorMarker(o,_){var M,y,I,O;if(!o)return;const k=o.markerGraphics;if(!k)return;const $=null!=(M=o.size)?M:10,tt=o.frame,lt=tt?tt.ymax-tt.ymin:0,ct=$&&lt?$/lt:1,_t=ot.createIdentity();tt&&_t.translate(.5*-(tt.xmax+tt.xmin),.5*-(tt.ymax+tt.ymin));const Pt=o.anchorPoint;if(Pt){let b=Pt.x,S=Pt.y;"Absolute"!==o.anchorPointUnits?tt&&(b*=tt.xmax-tt.xmin,S*=tt.ymax-tt.ymin):(b/=ct,S/=ct),_t.translate(-b,-S)}1!==ct&&_t.scale(ct,ct);let Mt=null!=(y=o.rotation)?y:0;o.rotateClockwise&&(Mt=-Mt),this._mapRotation&&(Mt+=this._mapRotation),Mt&&_t.rotate(Mt*Et);let L=null!=(I=o.offsetX)?I:0,l=null!=(O=o.offsetY)?O:0;if(L||l){if(this._mapRotation){const b=Et*this._mapRotation,S=Math.cos(b),P=Math.sin(b),v=L*P+l*S;L=L*S-l*P,l=v}_t.translate(L,l)}const m=this.geomUnitsPerPoint();1!==m&&_t.scale(m,m);const g=_.getAngle();g&&_t.rotate(g),_t.translate(_.tx,_.ty),this.push(_t,o.scaleSymbolsProportionally);for(const b of k)if(b&&b.symbol&&b.geometry||Rt.error("Invalid marker graphic",b),this.drawSymbol(b.symbol,b.geometry),this._earlyReturn)break;this.pop()}drawTextSymbol(o,_){var M,y,I,O;if(!o||!(0,T.wp)(_)||(null!=(M=o.height)?M:10)<=0)return;const k=ot.createIdentity();let $=null!=(y=o.angle)?y:0;$=-$,$&&k.rotate($*Et);const tt=null!=(I=o.offsetX)?I:0,lt=null!=(O=o.offsetY)?O:0;(tt||lt)&&k.translate(tt,lt);const ct=this.geomUnitsPerPoint();1!==ct&&k.scale(ct,ct),k.translate(_.x,_.y),this.push(k,!1),this.drawText(o),this.pop()}_buildHatchPolyline(o,_,M){let y=(void 0!==o.separation?o.separation:4)*M,I=void 0!==o.rotation?o.rotation:0;if(0===y)return null;y<0&&(y=-y);let O=0;const k=.5*y;for(;O>k;)O-=y;for(;O<-k;)O+=y;const $=(0,x.Ue)();(0,wt.$P)($,_),$[0]-=k,$[1]-=k,$[2]+=k,$[3]+=k;const tt=[[$[0],$[1]],[$[0],$[3]],[$[2],$[3]],[$[2],$[1]]];for(;I>180;)I-=180;for(;I<0;)I+=180;const lt=Math.cos(I*Et),ct=Math.sin(I*Et),_t=-y*ct,Pt=y*lt;let Mt,L,l,m;O=(void 0!==o.offsetX?o.offsetX*M:0)*ct-(void 0!==o.offsetY?o.offsetY*M:0)*lt,Mt=l=Number.MAX_VALUE,L=m=-Number.MAX_VALUE;for(const H of tt){const Y=H[0],it=H[1],pt=lt*Y+ct*it,at=-ct*Y+lt*it;Mt=Math.min(Mt,pt),l=Math.min(l,at),L=Math.max(L,pt),m=Math.max(m,at)}l=Math.floor(l/y)*y;let g=lt*Mt-ct*l-_t*O/y,b=ct*Mt+lt*l-Pt*O/y,S=lt*L-ct*l-_t*O/y,P=ct*L+lt*l-Pt*O/y;const v=1+Math.round((m-l)/y),C=[];for(let H=0;H<v;H++)g+=_t,b+=Pt,S+=_t,P+=Pt,C.push([[g,b],[S,P]]);return{paths:C}}}class V extends w{constructor(o,_){super(o,_),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new et.Z(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}bounds(){return(0,x.al)(this._xmin,this._ymin,this._xmax,this._ymax)}drawSolidFill(o){if(o&&!(this._clipCount>0))if((0,T.oU)(o))this._processPath(o.rings,0);else if((0,T.l9)(o))this._processPath(o.paths,0);else if((0,T.YX)(o)){const _=D(o);_&&this._processPath(_.rings,0)}else console.error("drawSolidFill Unexpected geometry type!")}drawSolidStroke(o,_,M){if(!o||this._clipCount>0)return;const y=.5*this.transformSize(M);if((0,T.oU)(o))this._processPath(o.rings,y);else if((0,T.l9)(o))this._processPath(o.paths,y);else if((0,T.YX)(o)){const I=D(o);I&&this._processPath(I.rings,y)}else console.error("drawSolidStroke unexpected geometry type!")}pushClipPath(o){this.drawSolidFill(o),++this._clipCount}popClipPath(){--this._clipCount}drawImage(o,_,M){let y=M*_,I=_;const O=this._resourceManager.getResource(o);!_&&(0,Z.pC)(O)&&(y=M*O.width,I=O.height),this._merge(this.transformPt([-y/2,-I/2]),0),this._merge(this.transformPt([-y/2,I/2]),0),this._merge(this.transformPt([y/2,-I/2]),0),this._merge(this.transformPt([y/2,I/2]),0)}drawText(o){this._textRasterizer||(this._textRasterizer=new mt.d)}_processPath(o,_){if(o)for(const M of o){const y=M?M.length:0;if(y>1){this._merge(this.transformPt(M[0]),_);for(let I=1;I<y;++I)this._merge(this.transformPt(M[I]),_)}}}_merge(o,_){o[0]-_<this._xmin&&(this._xmin=o[0]-_),o[0]+_>this._xmax&&(this._xmax=o[0]+_),o[1]-_<this._ymin&&(this._ymin=o[1]-_),o[1]+_>this._ymax&&(this._ymax=o[1]+_)}}class Q extends w{constructor(){super(...arguments),this._searchPoint=[0,0],this._searchDistPoint=0}hitTest(o,_,M,y,I,O){const k=O*(0,St.F2)(1);return this.setTransform(),this.setGeomUnitsPerPoint(k),this._searchPoint=[(o[0]+o[2])/2,(o[1]+o[3])/2],this._searchDistPoint=(o[2]-o[0])/2/k,this._textInfo=y,this._mapRotation=_&&("CIMPointSymbol"===_.type&&"Map"!==_.angleAlignment||"CIMTextSymbol"===_.type)?I:0,this._earlyReturn=!1,this.drawSymbol(_,M),this._earlyReturn}drawSolidFill(o,_){this._hitTestFill(o)}drawHatchFill(o,_){this._hitTestFill(o)}drawPictureFill(o,_){this._hitTestFill(o)}drawGradientFill(o,_){this._hitTestFill(o)}drawSolidStroke(o,_,M,y,I,O){this._hitTestStroke(o,M)}drawPictureStroke(o,_){this._hitTestStroke(o,_.width)}drawGradientStroke(o,_){this._hitTestStroke(o,_.width)}pushClipPath(o){}popClipPath(){}drawImage(o,_,M){const y=this._resourceManager.getResource(o);if((0,Z.Wi)(y)||0===y.height||0===_)return;const I=_*this.geomUnitsPerPoint(),O=I*M*(y.width/y.height),k=this.reverseTransformPt(this._searchPoint),$=this._searchDistPoint;Math.abs(k[0])<O/2+$&&Math.abs(k[1])<I/2+$&&(this._earlyReturn=!0)}drawText(o){var _,M;const y=this._textInfo;if(!y)return;const I=y.get(o);if(!I)return;const{text:O,mosaicItem:k}=I;if(!k||0===k.glyphMosaicItems.length)return;const $=null!=(_=o.height)?_:10,tt=st(o.lineGapType,null!=(M=o.lineGap)?M:0,$),lt=(0,ut.E)(O)[1],_t=(0,Lt.Nr)(k.glyphMosaicItems,lt,{scale:$/Ct.Ex,angle:0,xOffset:0,yOffset:0,hAlign:U(o.horizontalAlignment),vAlign:j(o.verticalAlignment),maxLineWidth:512,lineHeight:Ct.xm*Math.max(.25,Math.min(tt||1,4)),decoration:o.font.decoration||"none",isCIM:!0}),Pt=this.reverseTransformPt(this._searchPoint),Mt=Pt[0],L=Pt[1];for(const l of _t.glyphs)if(Mt>l.xTopLeft&&Mt<l.xBottomRight&&L>-l.yBottomRight&&L<-l.yTopLeft){this._earlyReturn=!0;break}}_hitTestFill(o){let _=null;if((0,T.YX)(o))_=[[[o.xmin,o.ymin],[o.xmin,o.ymax],[o.xmax,o.ymax],[o.xmax,o.ymin],[o.xmin,o.ymin]]];else if((0,T.oU)(o))_=o.rings;else{if(!(0,T.l9)(o))return;_=o.paths}const M=this.reverseTransformPt(this._searchPoint);this._pointInPolygon(M,_)&&(this._earlyReturn=!0);const y=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(M,_,y)&&(this._earlyReturn=!0)}_hitTestStroke(o,_){let M=null;if((0,T.YX)(o))M=[[[o.xmin,o.ymin],[o.xmin,o.ymax],[o.xmax,o.ymax],[o.xmax,o.ymin],[o.xmin,o.ymin]]];else if((0,T.oU)(o))M=o.rings;else{if(!(0,T.l9)(o))return;M=o.paths}const y=this.reverseTransformPt(this._searchPoint),I=_*this.geomUnitsPerPoint(),O=this.reverseTransformSize(this._searchDistPoint)*this.geomUnitsPerPoint();this._nearLine(y,M,I/2+O)&&(this._earlyReturn=!0)}_pointInPolygon(o,_){let M=0;for(const y of _){const I=y.length;for(let O=1;O<I;++O){const k=y[O-1],$=y[O];k[1]>o[1]!=$[1]>o[1]&&(($[0]-k[0])*(o[1]-k[1])-($[1]-k[1])*(o[0]-k[0])>0?M++:M--)}}return 0!==M}_nearLine(o,_,M){for(const y of _){const I=y.length;for(let O=1;O<I;++O){const k=y[O-1],$=y[O];let tt=($[0]-k[0])*($[0]-k[0])+($[1]-k[1])*($[1]-k[1]);if(0!==tt&&(tt=Math.sqrt(tt),Math.abs((($[0]-k[0])*(o[1]-k[1])-($[1]-k[1])*(o[0]-k[0]))/tt)<M)){const ct=(($[0]-k[0])*(o[0]-k[0])+($[1]-k[1])*(o[1]-k[1]))/tt;if(ct>-M&&ct<tt+M)return!0}}}return!1}}class E extends w{constructor(o,_,M){super(_,M),this._ctx=o}drawSolidFill(o,_){if(!o)return;if((0,T.oU)(o))this._buildPath(o.rings,!0);else if((0,T.l9)(o))this._buildPath(o.paths,!0);else if((0,T.YX)(o))this._buildPath(D(o).rings,!0);else{if(!(0,T.aW)(o))return;console.log("CanvasDrawHelper.drawSolidFill - No implementation!")}const M=this._ctx;M.fillStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",M.fill("evenodd")}drawSolidStroke(o,_,M,y,I,O){if(!o||!_||0===M)return;if((0,T.oU)(o))this._buildPath(o.rings,!0);else if((0,T.l9)(o))this._buildPath(o.paths,!1);else{if(!(0,T.YX)(o))return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");this._buildPath(D(o).rings,!0)}const k=this._ctx;k.strokeStyle="string"==typeof _?_:"rgba("+Math.round(_[0])+","+Math.round(_[1])+","+Math.round(_[2])+","+_[3]/255+")",k.lineWidth=this.transformSize(M)+.5,this._setCapStyle(y),this._setJoinStyle(I),k.miterLimit=O,k.stroke()}pushClipPath(o){if(this._ctx.save(),(0,T.oU)(o))this._buildPath(o.rings,!0);else if((0,T.l9)(o))this._buildPath(o.paths,!0);else{if(!(0,T.YX)(o))return;this._buildPath(D(o).rings,!0)}this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}drawImage(o,_,M){const y=this._resourceManager.getResource(o);if((0,Z.Wi)(y))return;const I=this._ctx,O=I.canvas.width,k=I.canvas.height;let $=_*M*(y.width/y.height),tt=M*_;_||($=M*y.width,tt=M*y.height),this._ctx.drawImage(y,0,0,y.width,y.height,0,0,Math.min(this.transformSize($),O),Math.min(this.transformSize(tt),k))}drawText(o){this._textRasterizer||(this._textRasterizer=new mt.d)}_buildPath(o,_){const M=this._ctx;if(M.beginPath(),o)for(const y of o){const I=y?y.length:0;if(I>1){let O=this.transformPt(y[0]);M.moveTo(O[0],O[1]);for(let k=1;k<I;++k)O=this.transformPt(y[k]),M.lineTo(O[0],O[1]);_&&M.closePath()}}}_setCapStyle(o){switch(o){case J.kP.Butt:this._ctx.lineCap="butt";break;case J.kP.Round:this._ctx.lineCap="round";break;case J.kP.Square:this._ctx.lineCap="square"}}_setJoinStyle(o){switch(o){case J.r4.Bevel:this._ctx.lineJoin="bevel";break;case J.r4.Round:this._ctx.lineJoin="round";break;case J.r4.Miter:this._ctx.lineJoin="miter"}}}const D=X=>X?{spatialReference:X.spatialReference,rings:[[[X.xmin,X.ymin],[X.xmin,X.ymax],[X.xmax,X.ymax],[X.xmax,X.ymin],[X.xmin,X.ymin]]]}:null,U=X=>{switch(X){case"Left":return bt.M7.Left;case"Right":return bt.M7.Right;case"Center":case"Justify":return bt.M7.Center}},j=X=>{switch(X){case"Top":return bt.TR.Top;case"Center":return bt.TR.Center;case"Bottom":return bt.TR.Bottom;case"Baseline":return bt.TR.Baseline}},st=(X,o,_)=>{switch(X){case"ExtraLeading":return 1+o/_;case"Multiple":return o;case"Exact":return o/_}}},35909:(Tt,gt,R)=>{R.d(gt,{IV:()=>st,B$:()=>X,E0:()=>_,fN:()=>o,U1:()=>ct,rW:()=>Q});var ut=R(91558),W=R(986),Z=R(36161),ht=R(58817),St=R(63290),x=R(21286),wt=R(62208),T=R(23841),F=R(65401),N=R(32442),K=R(97373),rt=R(89932),J=R(7547),et=R(80991),mt=R(86575),bt=R(39351),Ct=R(25797);const Lt=Math.PI,Et=Lt/2,ot=96/72,w=Math.PI/180,V=St.Z.getLogger("esri.symbols.cim.CIMSymbolHelper");function Q(L){if(!L||!L.type)return null;let l;switch(L.type){case"cim":return L.data;case"web-style":return L;case"simple-marker":l=X.fromSimpleMarker(L);break;case"picture-marker":l=X.fromPictureMarker(L);break;case"simple-line":l=X.fromSimpleLineSymbol(L);break;case"simple-fill":l=X.fromSimpleFillSymbol(L);break;case"picture-fill":l=X.fromPictureFillSymbol(L);break;case"text":l=X.fromTextSymbol(L)}return{type:"CIMSymbolReference",symbol:l}}function E(L,l){switch(l.type){case"CIMSymbolReference":return E(L,l.symbol);case"CIMPointSymbol":case"CIMTextSymbol":L.drawSymbol(l,{x:0,y:0});break;case"CIMLineSymbol":L.drawSymbol(l,{paths:[[[0,0],[0,1]]]});break;case"CIMPolygonSymbol":L.drawSymbol(l,{rings:[[[0,0],[0,1],[0,0]]]});break;case"CIMVectorMarker":{const m=new K.u;L.drawMarker(l,m);break}}return L.envelope()}function D(L){if(!L)return 0;switch(L.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAtExtremities":case"CIMMarkerPlacementAtMeasuredUnits":case"CIMMarkerPlacementAtRatioPositions":case"CIMMarkerPlacementOnLine":case"CIMMarkerPlacementOnVertices":return Math.abs(L.offset);default:return 0}}function U(L){if(!L)return 0;switch(L.type){case"CIMGeometricEffectArrow":return Math.abs(.5*L.width);case"CIMGeometricEffectBuffer":return Math.abs(L.size);case"CIMGeometricEffectExtension":case"CIMGeometricEffectRadial":return Math.abs(L.length);case"CIMGeometricEffectJog":return Math.abs(.5*L.length);case"CIMGeometricEffectMove":return Math.max(Math.abs((0,et.NA)(L.offsetX)),Math.abs((0,et.NA)(L.offsetY)));case"CIMGeometricEffectOffset":case"CIMGeometricEffectOffsetTangent":return Math.abs(L.offset);case"CIMGeometricEffectRegularPolygon":return Math.abs(L.radius);case"CIMGeometricEffectRotate":case"CIMGeometricEffectScale":default:return 0;case"CIMGeometricEffectTaperedPolygon":return.5*Math.max(Math.abs(L.fromWidth),Math.abs(L.toWidth));case"CIMGeometricEffectWave":return Math.abs(L.amplitude)}}function j(L){if(!L)return 0;let l=0;for(const m of L)l+=U(m);return l}class st{getSymbolInflateSize(l,m,g,b,S){return l||(l=[0,0,0,0]),m?this._getInflateSize(l,m,g,b,S):l}static safeSize(l){const m=Math.max(Math.abs(l[0]),Math.abs(l[2])),g=Math.max(Math.abs(l[1]),Math.abs(l[3]));return Math.sqrt(m*m+g*g)}_vectorMarkerBounds(l,m,g,b){let S=!0;const P=(0,F.Ue)();if(m&&m.markerGraphics)for(const v of m.markerGraphics){const C=[0,0,0,0];v.geometry&&((0,N.$P)(P,v.geometry),C[0]=0,C[1]=0,C[2]=0,C[3]=0,this.getSymbolInflateSize(C,v.symbol,g,0,b),P[0]+=C[0],P[1]+=C[1],P[2]+=C[2],P[3]+=C[3],S?(l[0]=P[0],l[1]=P[1],l[2]=P[2],l[3]=P[3],S=!1):(l[0]=Math.min(l[0],P[0]),l[1]=Math.min(l[1],P[1]),l[2]=Math.max(l[2],P[2]),l[3]=Math.max(l[3],P[3])))}return l}_getInflateSize(l,m,g,b,S){if(function _t(L){return void 0!==L.symbolLayers}(m)){const P=this._getLayersInflateSize(l,m.symbolLayers,g,b,S),v=j(m.effects);return v>0&&(P[0]-=v,P[1]-=v,P[2]+=v,P[3]+=v),P}return this._getTextInflatedSize(l,m,S)}_getLayersInflateSize(l,m,g,b,S){let P=!0;if(!m)return l;for(const v of m){if(!v)continue;let C=[0,0,0,0];switch(v.type){case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":{const Y=v;let it=Y.width;it/=Y.capStyle===J.kP.Square||Y.joinStyle===J.r4.Miter?1.4142135623730951:2,C[0]=-it,C[1]=-it,C[2]=it,C[3]=it;break}case"CIMCharacterMarker":case"CIMVectorMarker":case"CIMPictureMarker":{const Y=v;if("CIMVectorMarker"===v.type){const nt=v;if(C=this._vectorMarkerBounds(C,nt,g,S),nt.frame){const ft=(nt.frame.xmin+nt.frame.xmax)/2,It=(nt.frame.ymin+nt.frame.ymax)/2;C[0]-=ft,C[1]-=It,C[2]-=ft,C[3]-=It;const xt=nt.size/(nt.frame.ymax-nt.frame.ymin);C[0]*=xt,C[1]*=xt,C[2]*=xt,C[3]*=xt}}else if("CIMPictureMarker"===v.type){const nt=v,ft=g.getResource(nt.url);let It=1;(0,wt.pC)(ft)&&ft.height&&(It=ft.width/ft.height);const xt=Y.size/2,Dt=Y.size*It*nt.scaleX/2;C=[-Dt,-xt,Dt,xt]}else{const nt=Y.size/2;C=[-nt,-nt,nt,nt]}if(Y.anchorPoint){let nt,ft;"Absolute"===Y.anchorPointUnits?(nt=Y.anchorPoint.x,ft=Y.anchorPoint.y):(nt=Y.anchorPoint.x*(C[2]-C[0]),ft=Y.anchorPoint.y*(C[3]-C[1])),C[0]-=nt,C[1]-=ft,C[2]-=nt,C[3]-=ft}let it=(0,et.NA)(Y.rotation);if(Y.rotateClockwise&&(it=-it),b&&(it-=b),it){const nt=w*it,ft=Math.cos(nt),It=Math.sin(nt),xt=(0,F.Ue)([mt.B1,mt.B1,-mt.B1,-mt.B1]);(0,F.Ho)(xt,[C[0]*ft-C[1]*It,C[0]*It+C[1]*ft]),(0,F.Ho)(xt,[C[0]*ft-C[3]*It,C[0]*It+C[3]*ft]),(0,F.Ho)(xt,[C[2]*ft-C[1]*It,C[2]*It+C[1]*ft]),(0,F.Ho)(xt,[C[2]*ft-C[3]*It,C[2]*It+C[3]*ft]),C=xt}let pt=(0,et.NA)(Y.offsetX),at=(0,et.NA)(Y.offsetY);if(b){const nt=w*b,ft=Math.cos(nt),It=Math.sin(nt),xt=pt*It+at*ft;pt=pt*ft-at*It,at=xt}C[0]+=pt,C[1]+=at,C[2]+=pt,C[3]+=at;const dt=D(Y.markerPlacement);dt>0&&(C[0]-=dt,C[1]-=dt,C[2]+=dt,C[3]+=dt);break}}const H=j(v.effects);H>0&&(C[0]-=H,C[1]-=H,C[2]+=H,C[3]+=H),P?(l[0]=C[0],l[1]=C[1],l[2]=C[2],l[3]=C[3],P=!1):(l[0]=Math.min(l[0],C[0]),l[1]=Math.min(l[1],C[1]),l[2]=Math.max(l[2],C[2]),l[3]=Math.max(l[3],C[3]))}return l}_getTextInflatedSize(l,m,g){var b,S;const P=null!=(b=m.height)?b:10;if(l[0]=-P/2,l[1]=-P/2,l[2]=P/2,l[3]=P/2,!g)return l;const v=g.get(m);if(!v)return l;const{text:C,mosaicItem:H}=v;if(!H||0===H.glyphMosaicItems.length)return l;const Y=(0,rt.et)(m.lineGapType,null!=(S=m.lineGap)?S:0,P),it=(0,W.E)(C)[1],at=(0,Ct.Nr)(H.glyphMosaicItems,it,{scale:P/bt.Ex,angle:(0,et.NA)(m.angle),xOffset:(0,et.NA)(m.offsetX),yOffset:(0,et.NA)(m.offsetY),hAlign:(0,rt.x1)(m.horizontalAlignment),vAlign:(0,rt.g)(m.verticalAlignment),maxLineWidth:512,lineHeight:bt.xm*Math.max(.25,Math.min(Y||1,4)),decoration:m.font.decoration||"none",isCIM:!0}).boundsT;return l[0]=at.x-at.halfWidth,l[1]=-at.y-at.halfHeight,l[2]=at.x+at.halfWidth,l[3]=-at.y+at.halfHeight,l}}class X{static getEnvelope(l,m){const g=new rt.uQ(m);if(Array.isArray(l)){let b;for(const S of l)b?b.union(E(g,S)):b=E(g,S);return b}return E(g,l)}static getTextureAnchor(l,m){const g=this.getEnvelope(l,m);if(!g)return[0,0,0];const v=g.height*ot+2;return[(g.x+.5*g.width)*ot/(g.width*ot+2),-(g.y+.5*g.height)*ot/v,v]}static rasterize(l,m,g,b,S=!0){const P=g||this.getEnvelope(m,b);if(!P)return[null,0,0,0,0];const v=(P.x+.5*P.width)*ot,C=(P.y+.5*P.height)*ot;l.width=P.width*ot,l.height=P.height*ot,g||(l.width+=2,l.height+=2);const H=l.getContext("2d"),Y=rt.zA.createScale(ot,-ot);Y.translate(.5*l.width-v,.5*l.height+C);const it=new rt.cD(H,b,Y);switch(m.type){case"CIMPointSymbol":it.drawSymbol(m,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const dt=new K.u;it.drawMarker(m,dt);break}}const pt=H.getImageData(0,0,l.width,l.height),at=new Uint8Array(pt.data);if(S){let dt;for(let nt=0;nt<at.length;nt+=4)dt=at[nt+3]/255,at[nt]=at[nt]*dt,at[nt+1]=at[nt+1]*dt,at[nt+2]=at[nt+2]*dt}return[at,l.width,l.height,-v/l.width,-C/l.height]}static fromTextSymbol(l){const{angle:m,color:g,font:b,haloColor:S,haloSize:P,horizontalAlignment:v,kerning:C,text:H,verticalAlignment:Y,xoffset:it,yoffset:pt}=l;let at,dt,nt,ft,It;b&&(at=b.family,dt=b.style,nt=b.weight,ft=b.size,It=b.decoration);let xt=!1;return H&&(xt=(0,W.E)(H)[1]),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,anchorPointUnits:"Relative",dominantSizeAxis3D:"Y",size:10,billboardMode3D:"FaceNearPlane",frame:{xmin:-5,ymin:-5,xmax:5,ymax:5},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMTextSymbol",angle:m,blockProgression:J.zV.BTT,depth3D:1,extrapolateBaselines:!0,fontEffects:J.eZ.Normal,fontEncoding:J.DD.Unicode,fontFamilyName:at||"Arial",fontStyleName:$(dt,nt),fontType:J.Ky.Unspecified,haloSize:P,height:ft,hinting:J.Dd.Default,horizontalAlignment:I(null!=v?v:"center"),kerning:C,letterWidth:100,ligatures:!0,lineGapType:"Multiple",offsetX:(0,et.NA)(it),offsetY:(0,et.NA)(pt),strikethrough:"line-through"===It,underline:"underline"===It,symbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:k(g)}]},haloSymbol:{type:"CIMPolygonSymbol",symbolLayers:[{type:"CIMSolidFill",enable:!0,color:k(S)}]},shadowColor:[0,0,0,255],shadowOffsetX:1,shadowOffsetY:1,textCase:"Normal",textDirection:xt?J.UX.RTL:J.UX.LTR,verticalAlignment:O(null!=Y?Y:"baseline"),verticalGlyphOrientation:J.RS.Right,wordSpacing:100,billboardMode3D:J.UR.FaceNearPlane},textString:H}],scaleSymbolsProportionally:!0,respectFrame:!0}],scaleX:1,angleAlignment:"Display"}}static fromPictureFillSymbol(l){const{height:m,outline:g,width:b,xoffset:S,xscale:P,yoffset:v,yscale:C}=l,H=[],Y={type:"CIMPolygonSymbol",symbolLayers:H};if(g){const{cap:nt,join:ft,miterLimit:It,width:xt}=g;H.push({type:"CIMSolidStroke",color:k(g.color),capStyle:M(nt),joinStyle:y(ft),miterLimit:It,width:xt})}let it=l.url;"esriPFS"===l.type&&l.imageData&&(it=l.imageData);const pt="angle"in l?l.angle:0;return H.push({type:"CIMPictureFill",invertBackfaceTexture:!1,scaleX:1,textureFilter:J.Qb.Picture,tintColor:null,url:it,height:m*(C||1),width:b*(P||1),offsetX:(0,et.NA)(S),offsetY:(0,et.NA)(v),rotation:(0,et.NA)(-pt),colorSubstitutions:null}),Y}static fromSimpleFillSymbol(l){const{color:m,style:g,outline:b}=l,S=[],P={type:"CIMPolygonSymbol",symbolLayers:S};let v=null;if(b){const{cap:C,join:H,style:Y}=b;"solid"!==Y&&"none"!==Y&&"esriSLSSolid"!==Y&&"esriSLSNull"!==Y&&(v=[{type:"CIMGeometricEffectDashes",dashTemplate:ct(Y,C),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]),S.push({type:"CIMSolidStroke",color:k(b.color),capStyle:M(C),joinStyle:y(H),miterLimit:b.miterLimit,width:b.width,effects:v})}if(g&&"solid"!==g&&"none"!==g&&"esriSFSSolid"!==g&&"esriSFSNull"!==g){const C={type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",color:k(m),capStyle:J.kP.Butt,joinStyle:J.r4.Miter,width:.75}]};let H=0;const Y=(0,x.fp)(Math.ceil(window.devicePixelRatio)),it=Mt(g)?8*Y:10*Y;switch(g){case"vertical":case"esriSFSVertical":H=90;break;case"forward-diagonal":case"esriSFSForwardDiagonal":case"diagonal-cross":case"esriSFSDiagonalCross":H=-45;break;case"backward-diagonal":case"esriSFSBackwardDiagonal":H=45;break;case"cross":case"esriSFSCross":H=0}S.push({type:"CIMHatchFill",lineSymbol:C,offsetX:0,offsetY:0,rotation:H,separation:it}),"cross"===g||"esriSFSCross"===g?S.push({type:"CIMHatchFill",lineSymbol:(0,ht.d9)(C),offsetX:0,offsetY:0,rotation:90,separation:it}):"diagonal-cross"!==g&&"esriSFSDiagonalCross"!==g||S.push({type:"CIMHatchFill",lineSymbol:(0,ht.d9)(C),offsetX:0,offsetY:0,rotation:45,separation:it})}else!g||"solid"!==g&&"esriSFSSolid"!==g||S.push({type:"CIMSolidFill",enable:!0,color:k(m)});return P}static fromSimpleLineSymbol(l){const{cap:m,color:g,join:b,marker:S,miterLimit:P,style:v,width:C}=l;let H=null;"solid"!==v&&"none"!==v&&"esriSLSSolid"!==v&&"esriSLSNull"!==v&&(H=[{type:"CIMGeometricEffectDashes",dashTemplate:ct(v,m),lineDashEnding:"NoConstraint",scaleDash:!0,offsetAlongLine:null}]);const Y=[];if(S){let it;switch(S.placement){case"begin-end":it=J.Tx.Both;break;case"begin":it=J.Tx.JustBegin;break;case"end":it=J.Tx.JustEnd;break;default:it=J.Tx.None}const pt=X.fromSimpleMarker(S,C,g).symbolLayers[0];pt.markerPlacement={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:it,offsetAlongLine:0},Y.push(pt)}return"none"!==v&&"esriSLSNull"!==v&&Y.push({type:"CIMSolidStroke",color:k(g),capStyle:M(m),joinStyle:y(b),miterLimit:P,width:C,effects:H}),{type:"CIMLineSymbol",symbolLayers:Y}}static fromPictureMarker(l){const{angle:m,height:g,width:b,xoffset:S,yoffset:P}=l;let v=l.url;return"esriPMS"===l.type&&l.imageData&&(v=l.imageData),{type:"CIMPointSymbol",symbolLayers:[{type:"CIMPictureMarker",invertBackfaceTexture:!1,scaleX:1,textureFilter:J.Qb.Picture,tintColor:null,url:v,size:g,width:b,offsetX:(0,et.NA)(S),offsetY:(0,et.NA)(P),rotation:(0,et.NA)(-m)}]}}static fromSimpleMarker(l,m,g){var b;const{style:S}=l,P=null!=(b=l.color)?b:g;if("path"===S){const Y=[];if("outline"in l&&l.outline){const at=l.outline;Y.push({type:"CIMSolidStroke",enable:!0,width:(0,T.F2)(Math.round((0,T.Wz)(at.width))),color:k(at.color)})}Y.push({type:"CIMSolidFill",enable:!0,color:k(P),path:l.path});const[it,pt]=Pt("square");return{type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,et.NA)(-l.angle),size:(0,et.NA)(l.size||6),offsetX:(0,et.NA)(l.xoffset),offsetY:(0,et.NA)(l.yoffset),frame:it,markerGraphics:[{type:"CIMMarkerGraphic",geometry:pt,symbol:{type:"CIMPolygonSymbol",symbolLayers:Y}}]}]}}const[v,C]=Pt(S);let H;if(C&&v){const Y=[];if("outline"in l&&l.outline){const pt=l.outline;Y.push({type:"CIMSolidStroke",enable:!0,width:pt.width>.667?(0,T.F2)(Math.round((0,T.Wz)(pt.width))):pt.width,color:k(pt.color)})}else!m||"line-marker"!==l.type||"cross"!==l.style&&"x"!==l.style||Y.push({type:"CIMSolidStroke",enable:!0,width:m,color:k(P)});Y.push({type:"CIMSolidFill",enable:!0,color:k(P)});const it={type:"CIMPolygonSymbol",symbolLayers:Y};H={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:(0,et.NA)(-l.angle),size:(0,et.NA)(l.size||6*m),offsetX:(0,et.NA)(l.xoffset),offsetY:(0,et.NA)(l.yoffset),frame:v,markerGraphics:[{type:"CIMMarkerGraphic",geometry:C,symbol:it}]}]}}return H}static fromCIMHatchFill(l){var m;const g=null!=(m=l.separation)?m:4,b=g/2;let P=this._getLineSymbolPeriod(l.lineSymbol)||4;for(;P<4;)P*=2;const v=P/2;return{type:"CIMVectorMarker",frame:{xmin:-v,xmax:v,ymin:-b,ymax:b},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-v,0],[v,0]]]},symbol:l.lineSymbol}],size:g}}static _getLineSymbolPeriod(l){if(l){const m=this._getEffectsRepeat(l.effects);if(m)return m;if(l.symbolLayers)for(const g of l.symbolLayers){const b=this._getEffectsRepeat(g.effects);if(b)return b;if(g){const S=this._getPlacementRepeat(g.markerPlacement);if(S)return S}}}return 0}static _getEffectsRepeat(l){if(l)for(const m of l)if(m)switch(m.type){case"CIMGeometricEffectDashes":{const g=m.dashTemplate;if(g&&g.length){let b=0;for(const S of g)b+=S;return 1&g.length&&(b*=2),b}break}case"CIMGeometricEffectWave":return m.period;default:V.error(`unsupported geometric effect type ${m.type}`)}return 0}static _getPlacementRepeat(l){if(l)switch(l.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const m=l.placementTemplate;if(m&&m.length){let g=0;for(const b of m)g+=b;return 1&m.length&&(g*=2),g}break}}return 0}static fromCIMInsidePolygon(l){const m=l.markerPlacement,g=Ut({type:l.type},l);let b,S,P,v;return g.markerPlacement=null,g.anchorPoint=null,!0===m.shiftOddRows?(S=m.stepX/2,P=m.stepY,v=2*m.stepY,b=[{x:-S,y:0},{x:S,y:0},{x:0,y:P},{x:0,y:-P}].map(C=>({type:"CIMMarkerGraphic",geometry:C,symbol:{type:"CIMPointSymbol",symbolLayers:[g]}}))):(S=m.stepX/2,P=m.stepY/2,v=m.stepY,b=[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMPointSymbol",symbolLayers:[g]}}]),{type:"CIMVectorMarker",frame:{xmin:-S,xmax:S,ymin:-P,ymax:P},markerGraphics:b,size:v}}static getFillColor(l){if(!l)return null;switch(l.type){case"CIMPolygonSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const g=X.getFillColor(m);if(null!=g)return g}break;case"CIMTextSymbol":return X.getFillColor(l.symbol);case"CIMSolidFill":return l.color}}static getStrokeColor(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const g=X.getStrokeColor(m);if(void 0!==g)return g}break;case"CIMTextSymbol":return X.getStrokeColor(l.symbol);case"CIMSolidStroke":return l.color}}static getStrokeWidth(l){if(l)switch(l.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(l.symbolLayers)for(const m of l.symbolLayers){const g=X.getStrokeWidth(m);if(void 0!==g)return g}break;case"CIMTextSymbol":return X.getStrokeWidth(l.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return l.width}}static getSize(l){if(l)switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{let m=0;if(l.symbolLayers)for(const g of l.symbolLayers){const b=X.getSize(g);b>m&&(m=b)}return m}case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":return l.width;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":return l.size}}static getMarkerScaleRatio(l){return l&&"CIMVectorMarker"===l.type&&!1!==l.scaleSymbolsProportionally&&l.frame?l.size/(l.frame.ymax-l.frame.ymin):1}}class o{static rasterizeSimpleFill(l,m,g){"solid"!==m&&"none"!==m&&"esriSFSSolid"!==m&&"esriSFSNull"!==m||console.error("Unexpected: style does not require rasterization");const b=(0,x.fp)(Math.ceil(g)),S=Mt(m)?8*b:16*b,P=2*b;l.width=S,l.height=S;const v=l.getContext("2d");v.strokeStyle="#FFFFFF",v.lineWidth=b,v.beginPath(),"vertical"!==m&&"cross"!==m&&"esriSFSCross"!==m&&"esriSFSVertical"!==m||(v.moveTo(S/2,-P),v.lineTo(S/2,S+P)),"horizontal"!==m&&"cross"!==m&&"esriSFSCross"!==m&&"esriSFSHorizontal"!==m||(v.moveTo(-P,S/2),v.lineTo(S+P,S/2)),"forward-diagonal"!==m&&"diagonal-cross"!==m&&"esriSFSDiagonalCross"!==m&&"esriSFSForwardDiagonal"!==m||(v.moveTo(-P,-P),v.lineTo(S+P,S+P),v.moveTo(S-P,-P),v.lineTo(S+P,P),v.moveTo(-P,S-P),v.lineTo(P,S+P)),"backward-diagonal"!==m&&"diagonal-cross"!==m&&"esriSFSBackwardDiagonal"!==m&&"esriSFSDiagonalCross"!==m||(v.moveTo(S+P,-P),v.lineTo(-P,S+P),v.moveTo(P,-P),v.lineTo(-P,P),v.moveTo(S+P,S-P),v.lineTo(S-P,S+P)),v.stroke();const C=v.getImageData(0,0,l.width,l.height),H=new Uint8Array(C.data);let Y;for(let it=0;it<H.length;it+=4)Y=H[it+3]/255,H[it]=H[it]*Y,H[it+1]=H[it+1]*Y,H[it+2]=H[it+2]*Y;return[H,l.width,l.height]}static rasterizeSimpleLine(l,m){return this.rasterizeDash(l,m)}static rasterizeDash(l,m){const g="Butt"===m,b="Square"===m,S=!g&&!b;l.length%2==1&&(l=[...l,...l]);const P=15.5;let C=0;for(const xt of l)C+=xt;const H=Math.round(C*P),Y=new Float32Array(31*H);let pt=0,at=0,dt=.5,nt=!0;for(const xt of l){for(pt=at,at+=xt*P;dt<=at;){let Dt=.5;for(;Dt<31;){const Ft=(Dt-.5)*H+dt-.5,Ot=S?(Dt-P)*(Dt-P):Math.abs(Dt-P);Y[Ft]=nt?g?Math.max(Math.max(pt+7.75-dt,Ot),Math.max(dt-at+7.75,Ot)):Ot:S?Math.min((dt-pt)*(dt-pt)+Ot,(dt-at)*(dt-at)+Ot):b?Math.min(Math.max(dt-pt,Ot),Math.max(at-dt,Ot)):Math.min(Math.max(dt-pt+7.75,Ot),Math.max(at+7.75-dt,Ot)),Dt++}dt++}nt=!nt}const ft=Y.length,It=new Uint8Array(4*ft);for(let xt=0;xt<ft;++xt){const Dt=(S?Math.sqrt(Y[xt]):Y[xt])/P;(0,Z.I)(Dt,It,4*xt)}return[It,H,31]}}class _{static findApplicableOverrides(l,m,g){if(l&&m){if(l.primitiveName){let b=!1;for(const S of g)if(S.primitiveName===l.primitiveName){b=!0;break}if(!b)for(const S of m)S.primitiveName===l.primitiveName&&g.push(S)}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const b of l.effects)_.findApplicableOverrides(b,m,g);if(l.symbolLayers)for(const b of l.symbolLayers)_.findApplicableOverrides(b,m,g);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(l.effects)for(const b of l.effects)_.findApplicableOverrides(b,m,g);if(l.markerPlacement&&_.findApplicableOverrides(l.markerPlacement,m,g),"CIMVectorMarker"===l.type){if(l.markerGraphics)for(const b of l.markerGraphics)_.findApplicableOverrides(b,m,g),_.findApplicableOverrides(b.symbol,m,g)}else"CIMCharacterMarker"===l.type?_.findApplicableOverrides(l.symbol,m,g):"CIMHatchFill"===l.type&&_.findApplicableOverrides(l.lineSymbol,m,g)}}}static findEffectOverrides(l,m,g){if(!m||!l)return;const b=l.length;for(let S=0;S<b;S++){const P=l[S],v=null==P?void 0:P.primitiveName;if(v){let C=!1;for(const H of g)if(H.primitiveName===v){C=!0;break}if(!C)for(const H of m)H.primitiveName===v&&g.push(H)}}}static applyOverrides(l,m,g,b){if(!m)return;const S=P=>P&&P.charAt(0).toLowerCase()+P.substr(1);if(l.primitiveName)for(const P of m)if(P.primitiveName===l.primitiveName){const v=S(P.propertyName);if(b&&b.push({cim:l,nocapPropertyName:v,value:l[v]}),P.expression&&(P.value=_.toValue(P.propertyName,P.expression)),g){let C=!1;for(const H of g)H.primitiveName===l.primitiveName&&(C=!0);C||g.push(P)}l[v]=P.value}switch(l.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(l.effects)for(const P of l.effects)_.applyOverrides(P,m,g,b);if(l.symbolLayers)for(const P of l.symbolLayers)_.applyOverrides(P,m,g,b);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(l.effects)for(const P of l.effects)_.applyOverrides(P,m,g,b);if("CIMVectorMarker"===l.type&&l.markerGraphics)for(const P of l.markerGraphics)_.applyOverrides(P,m,g,b),_.applyOverrides(P.symbol,m,g,b)}}static restoreOverrides(l){for(const m of l)m.cim[m.nocapPropertyName]=m.value}static buildOverrideKey(l){let m="";for(const g of l)void 0!==g.value&&(m+=`${g.primitiveName}${g.propertyName}${JSON.stringify(g.value)}`);return m}static toValue(l,m){if("DashTemplate"===l)return m.split(" ").map(g=>Number(g));if("Color"===l){const g=new ut.Z(m).toRgba();return g[3]*=255,g}return m}}const M=L=>{if(!L)return J.kP.Butt;switch(L){case"butt":return J.kP.Butt;case"square":return J.kP.Square;case"round":return J.kP.Round}},y=L=>{if(!L)return J.r4.Miter;switch(L){case"miter":return J.r4.Miter;case"round":return J.r4.Round;case"bevel":return J.r4.Bevel}},I=L=>{if(!L)return"Center";switch(L){case"left":return"Left";case"right":return"Right";case"center":return"Center";case"justify":return"Justify"}},O=L=>{if(!L)return"Center";switch(L){case"baseline":return"Baseline";case"top":return"Top";case"middle":return"Center";case"bottom":return"Bottom"}},k=L=>{if(!L)return[0,0,0,0];const{r:l,g:m,b:g,a:b}=L;return[l,m,g,255*b]},$=(L,l)=>{const m=tt(l),g=lt(L);return m&&g?`${m}-${g}`:`${m}${g}`},tt=L=>{if(!L)return"";switch(L.toLowerCase()){case"bold":case"bolder":return"bold"}return""},lt=L=>{if(!L)return"";switch(L.toLowerCase()){case"italic":case"oblique":return"italic"}return""},ct=(L,l)=>{const m="butt"===l;switch(L){case"dash":case"esriSLSDash":return m?[4,3]:[3,4];case"dash-dot":case"esriSLSDashDot":return m?[4,3,1,3]:[3,4,0,4];case"dot":case"esriSLSDot":return m?[1,3]:[0,4];case"long-dash":case"esriSLSLongDash":return m?[8,3]:[7,4];case"long-dash-dot":case"esriSLSLongDashDot":return m?[8,3,1,3]:[7,4,0,4];case"long-dash-dot-dot":case"esriSLSDashDotDot":return m?[8,3,1,3,1,3]:[7,4,0,4,0,4];case"short-dash":case"esriSLSShortDash":return m?[4,1]:[3,2];case"short-dash-dot":case"esriSLSShortDashDot":return m?[4,1,1,1]:[3,2,0,2];case"short-dash-dot-dot":case"esriSLSShortDashDotDot":return m?[4,1,1,1,1,1]:[3,2,0,2,0,2];case"short-dot":case"esriSLSShortDot":return m?[1,1]:[0,2];case"solid":case"esriSLSSolid":case"none":return V.error("Unexpected: style does not require rasterization"),[0,0];default:return V.error(`Tried to rasterize SLS, but found an unexpected style: ${L}!`),[0,0]}},Pt=L=>{let g,b;const S=L;if("circle"===S||"esriSMSCircle"===S){let v=Math.acos(.995),C=Math.ceil(Lt/v/4);0===C&&(C=1),v=Et/C,C*=4;const H=[];H.push([50,0]);for(let Y=1;Y<C;Y++)H.push([50*Math.cos(Y*v),-50*Math.sin(Y*v)]);H.push([50,0]),g={rings:[H]},b={xmin:-50,ymin:-50,xmax:50,ymax:50}}else if("cross"===S||"esriSMSCross"===S)g={rings:[[[0,50],[0,0],[50,0],[50,-0],[0,-0],[0,-50],[-0,-50],[-0,-0],[-50,-0],[-50,0],[-0,0],[-0,50],[0,50]]]},b={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("diamond"===S||"esriSMSDiamond"===S)g={rings:[[[-50,0],[0,50],[50,0],[0,-50],[-50,0]]]},b={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("square"===S||"esriSMSSquare"===S)g={rings:[[[-50,-50],[-50,50],[50,50],[50,-50],[-50,-50]]]},b={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("x"===S||"esriSMSX"===S)g={rings:[[[0,0],[50,50],[50,50],[0,0],[50,-50],[50,-50],[0,-0],[-50,-50],[-50,-50],[-0,0],[-50,50],[-50,50],[0,0]]]},b={xmin:-50,ymin:-50,xmax:50,ymax:50};else if("triangle"===S||"esriSMSTriangle"===S){const P=57.735026918962575,v=-P,C=2/3*100,H=C-100;g={rings:[[[v,H],[0,C],[P,H],[v,H]]]},b={xmin:v,ymin:H,xmax:P,ymax:C}}else"arrow"===S&&(g={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},b={xmin:-50,ymin:-50,xmax:50,ymax:50});return[b,g]},Mt=L=>"vertical"===L||"horizontal"===L||"cross"===L||"esriSFSCross"===L||"esriSFSVertical"===L||"esriSFSHorizontal"===L},31375:(Tt,gt,R)=>{R.d(gt,{Z:()=>ut});class ut{constructor(Z=0,ht=0,St=0,x=0){this.x=Z,this.y=ht,this.width=St,this.height=x}get isEmpty(){return this.width<=0||this.height<=0}union(Z){this.x=Math.min(this.x,Z.x),this.y=Math.min(this.y,Z.y),this.width=Math.max(this.width,Z.width),this.height=Math.max(this.height,Z.height)}}},68937:(Tt,gt,R)=>{R.d(gt,{d:()=>ht});var ut=R(23841);class ht{constructor(){}rasterizeText(T,F){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const N=this._textRasterizationCanvas,K=N.getContext("2d");this._setFontProperties(K,F),this.parameters=F,this.textLines=T.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const rt=this._computeTextWidth(K,F),{decoration:J,weight:et}=F.font;this.lineThroughWidthOffset=J&&"line-through"===J?.1*this.lineHeight:0;const mt=this.lineHeight*this.textLines.length;N.width=rt+2*this.lineThroughWidthOffset,N.height=mt,this.renderedLineHeight=Math.round(this.lineHeight*F.pixelRatio),this.renderedHaloSize=F.halo.size*F.pixelRatio,this.renderedWidth=rt*F.pixelRatio,this.renderedHeight=mt*F.pixelRatio,this.lineThroughWidthOffset*=F.pixelRatio,this.fillStyle=function Z(wt){return`rgba(${wt.slice(0,3).toString()},${wt[3]})`}(F.color),this.haloStyle=function W(wt){return`rgb(${wt.slice(0,3).toString()})`}(F.halo.color);const bt=this.renderedLineHeight,Ct=this.renderedHaloSize;this._setFontProperties(K,F);const Lt=function St(wt,T){return"center"===wt?.5*T:"right"===wt?T:0}(K.textAlign,this.renderedWidth)+Ct,Et=Ct;let Rt=this.lineThroughWidthOffset,ot=0;Ct>0&&this._renderHalo(K,Lt,Et,Rt,ot,F),ot+=Et,Rt+=Lt;for(const D of this.textLines)K.globalCompositeOperation="destination-out",K.fillStyle="rgb(0, 0, 0)",K.fillText(D,Rt,ot),K.globalCompositeOperation="source-over",K.fillStyle=this.fillStyle,K.fillText(D,Rt,ot),J&&"none"!==J&&this._renderDecoration(K,Rt,ot,J,et),ot+=bt;const w=this.renderedWidth+2*this.lineThroughWidthOffset,V=this.renderedHeight,Q=K.getImageData(0,0,w,V),E=new Uint8Array(Q.data);if(F.premultiplyColors){let D;for(let U=0;U<E.length;U+=4)D=E[U+3]/255,E[U]=E[U]*D,E[U+1]=E[U+1]*D,E[U+2]=E[U+2]*D}return{size:[w,V],image:new Uint32Array(E.buffer),sdf:!1,simplePattern:!1,anchorX:0,anchorY:0}}_renderHalo(T,F,N,K,rt,J){const et=this.renderedWidth,mt=this.renderedHeight;this._haloRasterizationCanvas||(this._haloRasterizationCanvas=document.createElement("canvas")),this._haloRasterizationCanvas.width=et,this._haloRasterizationCanvas.height=mt;const bt=this._haloRasterizationCanvas,Ct=bt.getContext("2d");Ct.clearRect(0,0,et,mt),this._setFontProperties(Ct,J);const{decoration:Lt,weight:Et}=J.font;Ct.fillStyle=this.haloStyle,Ct.strokeStyle=this.haloStyle;const zt=this.renderedHaloSize<3;Ct.lineJoin=zt?"miter":"round",zt?this._renderHaloEmulated(Ct,F,N,Lt,Et):this._renderHaloNative(Ct,F,N,Lt,Et),T.globalAlpha=this.parameters.halo.color[3],T.drawImage(bt,0,0,et,mt,K,rt,et,mt),T.globalAlpha=1}_renderHaloEmulated(T,F,N,K,rt){const J=this.renderedLineHeight,et=this.renderedHaloSize;for(const mt of this.textLines){for(const[bt,Ct]of x)T.fillText(mt,F+et*bt,N+et*Ct);K&&"none"!==K&&this._renderDecoration(T,F,N,K,rt),N+=J}}_renderHaloNative(T,F,N,K,rt){const J=this.renderedLineHeight,et=this.renderedHaloSize;for(const mt of this.textLines){const bt=2*et,Ct=5,Lt=.1;for(let Et=0;Et<Ct;Et++)T.lineWidth=(1-(Ct-1)*Lt+Et*Lt)*bt,T.strokeText(mt,F,N),K&&"none"!==K&&this._renderDecoration(T,F,N,K,rt);N+=J}}_setFontProperties(T,F){const N=F.font,K=`${N.style} ${N.weight} ${(0,ut.F2)(F.size*F.pixelRatio)}px ${N.family}, sans-serif`;let rt;switch(T.font=K,T.textBaseline="top",F.horizontalAlignment){case"left":default:rt="left";break;case"right":rt="right";break;case"center":rt="center"}T.textAlign=rt}computeTextSize(T,F){this._textRasterizationCanvas||(this._textRasterizationCanvas=document.createElement("canvas"));const N=this._textRasterizationCanvas,K=N.getContext("2d");this._setFontProperties(K,F),this.parameters=F,this.textLines=T.split(/\r?\n/),this.lineHeight=this._computeLineHeight();const rt=this._computeTextWidth(K,F),J=this.lineHeight*this.textLines.length;return N.width=rt,N.height=J,[rt*F.pixelRatio,J*F.pixelRatio]}_computeTextWidth(T,F){let N=0;for(const rt of this.textLines)N=Math.max(N,T.measureText(rt).width);const K=F.font;return("italic"===K.style||"oblique"===K.style||"string"==typeof K.weight&&("bold"===K.weight||"bolder"===K.weight)||"number"==typeof K.weight&&K.weight>600)&&(N+=.3*T.measureText("w").width),N+=2*this.parameters.halo.size,Math.round(N)}_computeLineHeight(){let T=1.275*this.parameters.size;const F=this.parameters.font.decoration;return F&&"underline"===F&&(T*=1.3),Math.round(T+2*this.parameters.halo.size)}_renderDecoration(T,F,N,K,rt){const J=.9*this.lineHeight,et="bold"===rt?.06:"bolder"===rt?.09:.04;switch(T.textAlign){case"center":F-=this.renderedWidth/2;break;case"right":F-=this.renderedWidth}const mt=T.textBaseline;if("underline"===K)switch(mt){case"top":N+=J;break;case"middle":N+=J/2}else if("line-through"===K)switch(mt){case"top":N+=J/1.5;break;case"middle":N+=J/3}T.save(),T.beginPath(),T.strokeStyle=T.fillStyle,T.lineWidth=Math.ceil(J*et),T.moveTo(F-this.lineThroughWidthOffset,N),T.lineTo(F+this.renderedWidth+2*this.lineThroughWidthOffset,N),T.stroke(),T.restore()}}const x=[];for(let T=0;T<360;T+=22.5)x.push([Math.cos(Math.PI*T/180),Math.sin(Math.PI*T/180)])},25797:(Tt,gt,R)=>{R.d(gt,{Nr:()=>V});var ut=R(31478),W=R(12225),Z=R(67831),ht=R(9545),St=R(61261),x=R(5254),wt=R(84439);class T{constructor(E,D,U,j){this.center=(0,ht.f)(E,D),this.centerT=(0,ht.c)(),this.halfWidth=U/2,this.halfHeight=j/2,this.width=U,this.height=j}get x(){return this.center[0]}get y(){return this.center[1]}get blX(){return this.center[0]+this.halfWidth}get blY(){return this.center[1]+this.halfHeight}get trX(){return this.center[0]-this.halfWidth}get trY(){return this.center[1]-this.halfHeight}get xmin(){return this.x-this.halfWidth}get xmax(){return this.x+this.halfWidth}get ymin(){return this.y-this.halfHeight}get ymax(){return this.y+this.halfHeight}set x(E){this.center[0]=E}set y(E){this.center[1]=E}clone(){return new T(this.x,this.y,this.width,this.height)}serialize(E){return E.writeF32(this.center[0]),E.writeF32(this.center[1]),E.push(this.width),E.push(this.height),E}findCollisionDelta(E,D=4){const U=Math.abs(E.centerT[0]-this.centerT[0]),j=Math.abs(E.centerT[1]-this.centerT[1]),o=Math.min((E.halfWidth+this.halfWidth+D)/U,(E.halfHeight+this.halfHeight+D)/j);return Math.log2(o)}extend(E){const D=Math.min(this.xmin,E.xmin),U=Math.min(this.ymin,E.ymin),j=Math.max(this.xmax,E.xmax)-D,st=Math.max(this.ymax,E.ymax)-U,X=D+j/2,o=U+st/2;this.width=j,this.height=st,this.halfWidth=j/2,this.halfHeight=st/2,this.x=X,this.y=o}static deserialize(E){const D=E.readF32(),U=E.readF32(),j=E.readInt32(),st=E.readInt32();return new T(D,U,j,st)}}const mt=Math.PI/180;class bt{constructor(E,D,U,j){this._rotationT=(0,W.c)(),this._xBounds=0,this._yBounds=0,this.minZoom=0,this.maxZoom=255,this._bounds=null;const st=U.rect,X=new Float32Array(8);D*=j;const o=U.code?st.width*j:U.metrics.width,_=U.code?st.height*j:U.metrics.height;X[0]=E*=j,X[1]=D,X[2]=E+o,X[3]=D,X[4]=E,X[5]=D+_,X[6]=E+o,X[7]=D+_,this._data=X,this._setTextureCoords(st),this._scale=j,this._mosaic=U,this.x=E,this.y=D,this.maxOffset=Math.max(E+o,D+_)}get width(){return this._mosaic.metrics.width*this._scale}get mosaic(){return this._mosaic}set angle(E){this._angle=E,(0,ut.b)(this._rotationT,-E),this._setOffsets(this._data)}get angle(){return this._angle}get xTopLeft(){return this._data[0]}get yTopLeft(){return this._data[1]}get xBottomRight(){return this._data[6]}get yBottomRight(){return this._data[7]}get texcoords(){return this._texcoords}get textureBinding(){return this._mosaic.textureBinding}get offsets(){return this._offsets||this._setOffsets(this._data),this._offsets}get char(){return String.fromCharCode(this._mosaic.code)}get code(){return this._mosaic.code}get bounds(){if(!this._bounds){const{height:E,width:D}=this._mosaic.metrics,U=D*this._scale,j=Math.abs(E)*this._scale,st=new Float32Array(8);st[0]=this.x,st[1]=this.y,st[2]=this.x+U,st[3]=this.y,st[4]=this.x,st[5]=this.y+j,st[6]=this.x+U,st[7]=this.y+j;const X=(0,ut.m)((0,W.c)(),this._rotationT,this._T);(0,W.t)(st,st,X);let o=1/0,_=1/0,M=0,y=0;for(let tt=0;tt<4;tt++){const lt=st[2*tt],ct=st[2*tt+1];o=Math.min(o,lt),_=Math.min(_,ct),M=Math.max(M,lt),y=Math.max(y,ct)}const I=M-o,O=y-_;this._bounds=new T(o+I/2,_+O/2,I,O)}return this._bounds}setTransform(E){this._T=E,this._offsets=null}_setOffsets(E){this._offsets||(this._offsets={upperLeft:0,upperRight:0,lowerLeft:0,lowerRight:0});const D=this._offsets,U=new Float32Array(8),j=(0,ut.m)((0,W.c)(),this._rotationT,this._T);(0,W.t)(U,E,j),D.upperLeft=(0,x.UJ)(8*U[0],8*U[1]),D.upperRight=(0,x.UJ)(8*U[2],8*U[3]),D.lowerLeft=(0,x.UJ)(8*U[4],8*U[5]),D.lowerRight=(0,x.UJ)(8*U[6],8*U[7])}_setTextureCoords({x:E,y:D,width:U,height:j}){this._texcoords={upperLeft:(0,x.UJ)(E,D),upperRight:(0,x.UJ)(E+U,D),lowerLeft:(0,x.UJ)(E,D+j),lowerRight:(0,x.UJ)(E+U,D+j)}}}const Ct=(Q,E)=>({code:0,page:0,sdf:!0,rect:new wt.Z(0,0,11,8),textureBinding:E,metrics:{advance:0,height:4,width:Q,left:0,top:0}});class Lt{constructor(E,D,U){this._rotation=0,this._decorate(E,D,U),this.glyphs=E,this.bounds=this._createBounds(E),this.isMultiline=D.length>1,this._hasRotation=0!==U.angle,this._T=this._createGlyphTransform(this.bounds,U);for(const j of E)j.setTransform(this._T)}setRotation(E){if(0===E&&0===this._rotation)return;this._rotation=E;const D=this._T,U=(0,ut.b)((0,W.c)(),E);(0,ut.m)(D,U,D);for(const j of this.glyphs)j.setTransform(this._T)}_decorate(E,D,U){if(!U.decoration||"none"===U.decoration||!E.length)return;const j=U.scale,st="underline"===U.decoration?30:20,X=E[0].textureBinding;for(const o of D)E.push(new bt(o.startX*j,o.startY*j+st*j,Ct((o.width+o.glyphWidthEnd)*j,X),1))}get boundsT(){const E=this.bounds,D=(0,Z.s)((0,ht.c)(),E.x,E.y);if((0,Z.t)(D,D,this._T),this._hasRotation){const U=Math.max(E.width,E.height);return new T(D[0],D[1],U,U)}return new T(D[0],D[1],E.width,E.height)}_createBounds(E){let D=1/0,U=1/0,j=0,st=0;for(const _ of E)D=Math.min(D,_.xTopLeft),U=Math.min(U,_.yTopLeft),j=Math.max(j,_.xTopLeft+_.width),st=Math.max(st,_.yBottomRight);const X=j-D,o=st-U;return new T(D+X/2,U+o/2,X,o)}_createGlyphTransform(E,D){const U=mt*D.angle,j=(0,W.c)(),st=(0,ht.c)();return(0,ut.t)(j,j,(0,Z.s)(st,D.xOffset,-D.yOffset)),D.isCIM?(0,ut.r)(j,j,U):((0,ut.t)(j,j,(0,Z.s)(st,E.x,E.y)),(0,ut.r)(j,j,U),(0,ut.t)(j,j,(0,Z.s)(st,-E.x,-E.y))),j}}class Et{constructor(E,D,U,j,st,X){this.glyphWidthEnd=0,this.startX=0,this.startY=0,this.start=Math.max(0,Math.min(D,U)),this.end=Math.max(0,Math.max(D,U)),this.end<E.length&&(this.glyphWidthEnd=E[this.end].metrics.width),this.width=j,this.yMin=st,this.yMax=X}}const zt=Q=>10===Q,Rt=Q=>32===Q;function V(Q,E,D){const U=D.scale,j=new Array,st=function ot(Q,E,D){const U=new Array,st=D.maxLineWidth*(1/D.scale),X=E?Q.length-1:0,o=E?-1:Q.length,_=E?-1:1;let M=X,y=0,I=0,O=M,k=O,$=0,tt=1/0,lt=0;for(;M!==o;){const{code:_t,metrics:Pt}=Q[M],Mt=Math.abs(Pt.top);zt(_t)||Rt(_t)||(tt=Math.min(tt,Mt),lt=Math.max(lt,Mt+Pt.height)),zt(_t)?(M!==X&&(U.push(new Et(Q,O,M-_,y,tt,lt)),tt=1/0,lt=0),y=0,O=M+_,k=M+_,I=0):Rt(_t)?(k=M+_,I=0,$=Pt.advance,y+=Pt.advance):y>st?(k!==O?(y-=$,U.push(new Et(Q,O,k-2*_,y-I,tt,lt)),tt=1/0,lt=0,O=k,y=I):(U.push(new Et(Q,O,M-_,y,tt,lt)),tt=1/0,lt=0,O=M,k=M,y=0),y+=Pt.advance,I+=Pt.advance):(y+=Pt.advance,I+=Pt.advance),M+=_}const ct=new Et(Q,O,M-_,y,tt,lt);return ct.start>=0&&ct.end<Q.length&&U.push(ct),U}(Q,E,D),X=function w(Q,E){let D=0;for(let st=0;st<Q.length;st++){const{width:X}=Q[st];D=Math.max(X,D)}const j=Q[0].yMin;return{x:0,y:j,height:Q[Q.length-1].yMax+E.lineHeight*(Q.length-1)+("underline"===E.decoration?4:0)-j,width:D}}(st,D),{vAlign:o,hAlign:_}=D,M=o===St.TR.Baseline?1:0,I=(1-M)*-X.y+X.height/2*(M?0:o-1)+-26*(M?1:0);for(let O=0;O<st.length;O++){const{start:k,end:$,width:tt}=st[O];let lt=-1*(_+1)*(tt/2)-3;const ct=O*D.lineHeight+I-3;st[O].startX=lt,st[O].startY=ct;for(let _t=k;_t<=$;_t++){const Pt=Q[_t];if(zt(Pt.code))continue;const Mt=new bt(lt+Pt.metrics.left,ct-Pt.metrics.top,Pt,U);lt+=Pt.metrics.advance,j.push(Mt)}}return new Lt(j,st,D)}}}]);