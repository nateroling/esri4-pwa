"use strict";var V=Object.defineProperty,v=Object.getOwnPropertySymbols,z=Object.prototype.hasOwnProperty,W=Object.prototype.propertyIsEnumerable,w=(C,D,c)=>D in C?V(C,D,{enumerable:!0,configurable:!0,writable:!0,value:c}):C[D]=c,H=(C,D)=>{for(var c in D||(D={}))z.call(D,c)&&w(C,c,D[c]);if(v)for(var c of v(D))W.call(D,c)&&w(C,c,D[c]);return C};(self.webpackChunkesri4_pwa=self.webpackChunkesri4_pwa||[]).push([[5314],{83994:(C,D,c)=>{c.d(D,{f:()=>_});var M=c(15861),O=c(85931),i=c(63290),S=c(62208),g=c(55713),N=c(81653),e=c(57596),n=c(67969);const E=i.Z.getLogger("esri.views.webgl.BufferObject");class _{constructor(s,a,u,l){this._context=s,this.bufferType=a,this.usage=u,this._glName=null,this._size=-1,this._indexType=void 0,s.instanceCounter.increment(n._g.Buffer,this),this._glName=this._context.gl.createBuffer(),(0,N.zu)(this._context.gl),l&&this.setData(l)}static createIndex(s,a,u){return new _(s,n.w0.ELEMENT_ARRAY_BUFFER,a,u)}static createVertex(s,a,u){return new _(s,n.w0.ARRAY_BUFFER,a,u)}static createUniform(s,a,u){if(s.type!==e.zO.WEBGL2)throw new Error("Uniform buffers are supported in WebGL2 only!");return new _(s,n.w0.UNIFORM_BUFFER,a,u)}static createPixelPack(s,a=n.l1.STREAM_READ,u){if(s.type!==e.zO.WEBGL2)throw new Error("Pixel pack buffers are supported in WebGL2 only!");const l=new _(s,n.w0.PIXEL_PACK_BUFFER,a);return u&&l.setSize(u),l}static createPixelUnpack(s,a=n.l1.STREAM_DRAW,u){if(s.type!==e.zO.WEBGL2)throw new Error("Pixel unpack buffers are supported in WebGL2 only!");return new _(s,n.w0.PIXEL_UNPACK_BUFFER,a,u)}get glName(){return this._glName}get size(){return this._size}get indexType(){return this._indexType}get byteSize(){return this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER?this._indexType===n.g.UNSIGNED_INT?4*this._size:2*this._size:this._size}get _isVAOAware(){return this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER||this.bufferType===n.w0.ARRAY_BUFFER}dispose(){var s;null!=(s=this._context)&&s.gl?(this._glName&&(this._context.gl.deleteBuffer(this._glName),this._glName=null),this._context.instanceCounter.decrement(n._g.Buffer,this),this._context=null):this._glName&&E.warn("Leaked WebGL buffer object")}setSize(s,a=null){if(s<=0&&E.error("Buffer size needs to be positive!"),this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&(0,S.pC)(a))switch(this._indexType=a,a){case n.g.UNSIGNED_SHORT:s*=2;break;case n.g.UNSIGNED_INT:s*=4}this._setBufferData(s)}setData(s){if(!s)return;let a=s.byteLength;this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&((0,g.Uc)(s)&&(a/=2,this._indexType=n.g.UNSIGNED_SHORT),(0,g.ZY)(s)&&(a/=4,this._indexType=n.g.UNSIGNED_INT)),this._setBufferData(a,s)}_setBufferData(s,a=null){this._size=s;const u=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const l=this._context.gl;(0,S.pC)(a)?l.bufferData(this.bufferType,a,this.usage):l.bufferData(this.bufferType,s,this.usage),(0,N.zu)(l),this._isVAOAware&&this._context.bindVAO(u)}setSubData(s,a=0,u=0,l=s.byteLength){if(!s)return;(a<0||a>=this._size)&&E.error("offset is out of range!");let T=a,h=u,b=l,m=s.byteLength;this.bufferType===n.w0.ELEMENT_ARRAY_BUFFER&&((0,g.Uc)(s)?(m/=2,T*=2,h*=2,b*=2):(0,g.ZY)(s)&&(m/=4,T*=4,h*=4,b*=4)),void 0===l&&(l=m-1),u>=l&&E.error("end must be bigger than start!"),a+u-l>this._size&&E.error("An attempt to write beyond the end of the buffer!");const t=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const r=this._context.gl,o=ArrayBuffer.isView(s)?s.buffer:s,f=0===h&&b===s.byteLength?o:o.slice(h,b);r.bufferSubData(this.bufferType,T,f),(0,N.zu)(r),this._isVAOAware&&this._context.bindVAO(t)}setSubDataFromView(s,a,u,l){if(!s)return;(a<0||a>=this._size)&&E.error("offset is out of range!"),u>=l&&E.error("end must be bigger than start!"),a+u-l>this._size&&E.error("An attempt to write beyond the end of the buffer!");const T=this._context.getBoundVAO();this._isVAOAware&&this._context.bindVAO(null),this._context.bindBuffer(this);const h=this._context.gl;if(this._context.type===e.zO.WEBGL2)h.bufferSubData(this.bufferType,a*s.BYTES_PER_ELEMENT,s,u,l-u);else{const b=0===u&&l===s.length?s:s.subarray(u,l);h.bufferSubData(this.bufferType,a*s.BYTES_PER_ELEMENT,b)}(0,N.zu)(h),this._isVAOAware&&this._context.bindVAO(T)}getSubData(s,a=0,u,l){if(this._context.type!==e.zO.WEBGL2)return void E.error("Get buffer subdata is supported in WebGL2 only!");if(u<0||l<0)return void E.error("Problem getting subdata: offset and length were less than zero!");const T=function p(d){return(0,O.zG)(d)}(s)?s.BYTES_PER_ELEMENT:1;if(T*((null!=u?u:0)+(null!=l?l:0))>s.byteLength)return void E.error("Problem getting subdata: offset and length exceeded destination size!");a+T*(null!=l?l:0)>this.byteSize&&E.warn("Potential problem getting subdata: requested data exceeds buffer size!");const h=this._context.gl;this._context.bindBuffer(this,n.w0.COPY_READ_BUFFER),h.getBufferSubData(n.w0.COPY_READ_BUFFER,a,s,u,l),this._context.unbindBuffer(n.w0.COPY_READ_BUFFER)}getSubDataAsync(s,a=0,u,l){var T=this;return(0,M.Z)(function*(){T._context.type===e.zO.WEBGL2?(yield T._context.clientWaitAsync(),T.getSubData(s,a,u,l)):E.error("Get buffer subdata is supported in WebGL2 only!")})()}}},85775:(C,D,c)=>{c.d(D,{X:()=>d});var M=c(15861),O=c(63290),i=c(62208),S=c(83994),g=c(81653),N=c(57596),e=c(67969),n=c(49266),E=c(55086),p=c(26906);const _=O.Z.getLogger("esri.views.webgl.FrameBufferObject");class d{constructor(t,r,o=null,f=null){if(this._context=t,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachments=new Map,this._initialized=!1,this._desc=H({},r),t.instanceCounter.increment(e._g.Framebuffer,this),(0,i.pC)(o)){Array.isArray(o)||(o=[o]);for(let A=0;A<o.length;++A){const R=o[A],x=e.VY.COLOR_ATTACHMENT0+A;let P;u(R)?(s(R)?(P=R.descriptor,this._colorAttachments.set(x,R)):(P=R,this._colorAttachments.set(x,new E.x(this._context,P))),T(P,this._desc)):(a(R)?(P=R.descriptor,this._colorAttachments.set(x,R)):(P=R,this._colorAttachments.set(x,new n.r(this._context,P))),h(P,this._desc)),this._validateColorAttachmentPoint(x)}}if((0,i.pC)(f)){let A,R;if(u(f))this._context.capabilities.depthTexture||console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"),s(f)?(R=f.descriptor,this._depthStencilTexture=f):(R=f,this._depthStencilTexture=new E.x(this._context,R)),T(R,this._desc);else{var B;a(f)?(R=f.descriptor,A=f):(R=f,A=new n.r(this._context,R));const x=null!=(B=this._desc.depthStencilTarget)?B:e.OU.DEPTH_STENCIL_RENDER_BUFFER;x===e.OU.STENCIL_RENDER_BUFFER?this._stencilAttachment=A:x===e.OU.DEPTH_RENDER_BUFFER||x===e.OU.DEPTH_STENCIL_RENDER_BUFFER?this._depthAttachment=A:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),h(R,this._desc)}}}dispose(){if(!this._desc)return;const t=this._context.getBoundFramebufferObject();this._disposeColorAttachments(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),this._context.bindFramebuffer(t),this._context.instanceCounter.decrement(e._g.Framebuffer,this),this._desc=null}get glName(){return this._glName}get descriptor(){return this._desc}get colorTexture(){const t=this._colorAttachments.get(e.VY.COLOR_ATTACHMENT0);return t&&s(t)?t:null}get colorAttachment(){return this._colorAttachments.get(e.VY.COLOR_ATTACHMENT0)}get depthStencilAttachment(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment}get depthStencilTexture(){return this._depthStencilTexture}get width(){return this._desc.width}get height(){return this._desc.height}get gpuMemoryUsage(){return[...this._colorAttachments].reduce((t,[r,o])=>t+(0,p.un)(o),0)+(0,p.un)(this.depthStencilAttachment)}getColorTexture(t){const r=this._colorAttachments.get(t);return r&&s(r)?r:null}attachColorTexture(t,r=e.VY.COLOR_ATTACHMENT0){!t||(this._validateColorAttachmentPoint(r),T(t.descriptor,this._desc),this._disposeColorAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,r)),this._colorAttachments.set(r,t))}detachColorTexture(t=e.VY.COLOR_ATTACHMENT0){const r=this._colorAttachments.get(t);if(s(r)){const o=r;return this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)),this._colorAttachments.delete(t),o}}setColorTextureTarget(t,r=e.VY.COLOR_ATTACHMENT0){const o=this._colorAttachments.get(r);s(o)&&this._framebufferTexture2D(o.glName,r,t)}attachDepthStencilTexture(t){if((0,i.Wi)(t))return;const r=t.descriptor;r.pixelFormat!==e.VI.DEPTH_STENCIL&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),r.dataType!==e.Br.UNSIGNED_INT_24_8&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),T(r,this._desc),this._desc.depthStencilTarget&&this._desc.depthStencilTarget!==e.OU.DEPTH_STENCIL_TEXTURE&&(this._desc.depthStencilTarget=e.OU.DEPTH_STENCIL_TEXTURE),this._disposeDepthStencilAttachments(),this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(t.glName,e.Lu)),this._depthStencilTexture=t}detachDepthStencilTexture(){const t=this._depthStencilTexture;return t&&this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,e.Lu)),this._depthStencilTexture=null,t}attachDepthStencilBuffer(t){if((0,i.Wi)(t))return;const r=t.descriptor;if(r.internalFormat!==e.Tg.DEPTH_STENCIL&&r.internalFormat!==e.Tg.DEPTH_COMPONENT16&&console.error("Depth/Stencil buffer must have correct internalFormat"),h(r,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=r.internalFormat===e.Tg.DEPTH_STENCIL?e.OU.DEPTH_STENCIL_RENDER_BUFFER:e.OU.DEPTH_RENDER_BUFFER,this._initialized){this._context.bindFramebuffer(this);const o=this._context.gl;o.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?o.DEPTH_ATTACHMENT:o.DEPTH_STENCIL_ATTACHMENT,o.RENDERBUFFER,t.glName)}this._depthAttachment=t}detachDepthStencilBuffer(){const t=this._context.gl,r=this._depthAttachment;return r&&this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._depthAttachment=null,r}detachAll(){this._colorAttachments.forEach((t,r)=>this._detachColorAttachment(r)),this.detachDepthStencilBuffer(),this.detachDepthStencilTexture()}copyToTexture(t,r,o,f,B,A,R){(t<0||r<0||B<0||A<0)&&console.error("Offsets cannot be negative!"),(o<=0||f<=0)&&console.error("Copy width and height must be greater than zero!");const x=this._desc,P=R.descriptor;R.descriptor.target!==e.No.TEXTURE_2D&&console.error("Texture target must be TEXTURE_2D!"),(t+o>x.width||r+f>x.height||B+o>P.width||A+f>P.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");const F=this._context,L=F.bindTexture(R,E.x.TEXTURE_UNIT_FOR_UPDATES);F.setActiveTexture(E.x.TEXTURE_UNIT_FOR_UPDATES),F.bindFramebuffer(this),F.gl.copyTexSubImage2D(e.No.TEXTURE_2D,0,B,A,t,r,o,f),F.bindTexture(L,E.x.TEXTURE_UNIT_FOR_UPDATES)}readPixels(t,r,o,f,B,A,R){(o<=0||f<=0)&&console.error("Copy width and height must be greater than zero!"),R||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(t,r,o,f,B,A,R)}readPixelsAsync(t,r,o,f,B,A,R){var x=this;return(0,M.Z)(function*(){if(x._context.type!==N.zO.WEBGL2)return(0,g.hZ)()&&console.warn("Attempting to read pixels using pixel buffer object without WebGL2"),void x.readPixels(t,r,o,f,B,A,R);const P=x._context.gl,F=S.f.createPixelPack(x._context,e.l1.STREAM_READ,R.byteLength);x._context.bindBuffer(F),x._context.bindFramebuffer(x),P.readPixels(t,r,o,f,B,A,0),x._context.unbindBuffer(e.w0.PIXEL_PACK_BUFFER),yield F.getSubDataAsync(R),F.dispose()})()}resize(t,r){const o=this._desc;if(o.width!==t||o.height!==r){if(!this._initialized)return o.width=t,o.height=r,this._colorAttachments.forEach(f=>{f&&f.resize(t,r)}),void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,r));o.width=t,o.height=r,this._colorAttachments.forEach(f=>{f&&f.resize(t,r)}),null!=this._depthStencilTexture?this._depthStencilTexture.resize(t,r):(this._depthAttachment||this._stencilAttachment)&&(this._depthAttachment&&this._depthAttachment.resize(t,r),this._stencilAttachment&&this._stencilAttachment.resize(t,r)),this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}}initializeAndBind(t=e.qi.FRAMEBUFFER){var r,o,f,B;const A=this._context.gl;if(this._initialized)return void A.bindFramebuffer(t,this.glName);this._glName&&A.deleteFramebuffer(this._glName);const R=this._context,x=A.createFramebuffer(),P=this._desc,F=null!=(r=P.colorTarget)?r:e.Lm.RENDER_BUFFER,L=null!=(o=P.width)?o:1,I=null!=(f=P.height)?f:1;if(A.bindFramebuffer(t,x),0===this._colorAttachments.size)if(F===e.Lm.TEXTURE||F===e.Lm.CUBEMAP)this._colorAttachments.set(e.VY.COLOR_ATTACHMENT0,function l(m,t,r){return new E.x(m,{target:r,pixelFormat:e.VI.RGBA,dataType:e.Br.UNSIGNED_BYTE,samplingMode:e.cw.NEAREST,wrapMode:e.e8.CLAMP_TO_EDGE,width:t.width,height:t.height})}(R,P,this.descriptor.colorTarget===e.Lm.CUBEMAP?e.No.TEXTURE_CUBE_MAP:e.No.TEXTURE_2D));else{const U=new n.r(R,{internalFormat:e.lP.RGBA4,width:L,height:I});this._colorAttachments.set(e.VY.COLOR_ATTACHMENT0,U)}this._colorAttachments.forEach((U,G)=>{U&&(s(U)?this._framebufferTexture2D(U.glName,G,b(U),t):A.framebufferRenderbuffer(t,G,A.RENDERBUFFER,U.glName))});const y=null!=(B=P.depthStencilTarget)?B:e.OU.NONE;switch(y){case e.OU.DEPTH_RENDER_BUFFER:case e.OU.DEPTH_STENCIL_RENDER_BUFFER:this._depthAttachment||(this._depthAttachment=new n.r(R,{internalFormat:P.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?e.Tg.DEPTH_COMPONENT16:e.Tg.DEPTH_STENCIL,width:L,height:I})),A.framebufferRenderbuffer(t,y===e.OU.DEPTH_RENDER_BUFFER?A.DEPTH_ATTACHMENT:A.DEPTH_STENCIL_ATTACHMENT,A.RENDERBUFFER,this._depthAttachment.glName);break;case e.OU.STENCIL_RENDER_BUFFER:this._stencilAttachment||(this._stencilAttachment=new n.r(R,{internalFormat:e.Tg.STENCIL_INDEX8,width:L,height:I})),A.framebufferRenderbuffer(t,A.STENCIL_ATTACHMENT,A.RENDERBUFFER,this._stencilAttachment.glName);break;case e.OU.DEPTH_STENCIL_TEXTURE:this._depthStencilTexture||(R.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!"),this._depthStencilTexture=new E.x(R,{target:e.No.TEXTURE_2D,pixelFormat:e.VI.DEPTH_STENCIL,dataType:e.Br.UNSIGNED_INT_24_8,samplingMode:e.cw.NEAREST,wrapMode:e.e8.CLAMP_TO_EDGE,width:L,height:I})),this._framebufferTexture2D(this._depthStencilTexture.glName,A.DEPTH_STENCIL_ATTACHMENT,b(this._depthStencilTexture),t)}(0,g.CG)()&&A.checkFramebufferStatus(t)!==A.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=x,this._initialized=!0}_framebufferTexture2D(t,r=e.VY.COLOR_ATTACHMENT0,o=e.No.TEXTURE_2D,f=e.qi.FRAMEBUFFER,B=0){this._context.gl.framebufferTexture2D(f,r,o,t,B)}_detachColorAttachment(t){(0,g.hZ)()&&console.warn("Detaching an FBO attachment can be a slow due to invalidating framebuffer completeness!");const r=this._context.gl,o=this._colorAttachments.get(t);return s(o)?this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t)):this._initialized&&(this._context.bindFramebuffer(this),r.framebufferRenderbuffer(e.qi.FRAMEBUFFER,t,r.RENDERBUFFER,null)),this._colorAttachments.delete(t),o}_disposeColorAttachments(){this._colorAttachments.forEach((t,r)=>{this._detachColorAttachment(r),t.dispose()}),this._colorAttachments.clear()}_disposeDepthStencilAttachments(){const t=this._context.gl;this._depthAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,this._desc.depthStencilTarget===e.OU.DEPTH_RENDER_BUFFER?t.DEPTH_ATTACHMENT:t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._depthAttachment.dispose(),this._depthAttachment=null),this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),t.framebufferRenderbuffer(e.qi.FRAMEBUFFER,t.STENCIL_ATTACHMENT,t.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),this._framebufferTexture2D(null,t.DEPTH_STENCIL_ATTACHMENT)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)}_validateColorAttachmentPoint(t){if(-1===d._MAX_COLOR_ATTACHMENTS){const o=this._context.capabilities.drawBuffers;d._MAX_COLOR_ATTACHMENTS=o?this._context.gl.getParameter(o.MAX_COLOR_ATTACHMENTS):1}const r=t-e.VY.COLOR_ATTACHMENT0;r+1>d._MAX_COLOR_ATTACHMENTS&&_.error("esri.FrameBufferObject",`illegal attachment point for color attachment: ${r+1}. Implementation supports up to ${d._MAX_COLOR_ATTACHMENTS} color attachments`)}}function s(m){return"type"in m&&"texture"===m.type}function a(m){return"type"in m&&"renderbuffer"===m.type}function u(m){return s(m)||"pixelFormat"in m}function T(m,t){m.target!==e.No.TEXTURE_2D&&m.target!==e.No.TEXTURE_CUBE_MAP&&console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"),void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===m.width&&t.height===m.height||console.error("Color attachment texture must match the framebuffer's!"):(t.width=m.width,t.height=m.height)}function h(m,t){void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===m.width&&t.height===m.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(t.width=m.width,t.height=m.height)}function b(m){return m.descriptor.target===e.No.TEXTURE_CUBE_MAP?e.No.TEXTURE_CUBE_MAP_POSITIVE_X:e.No.TEXTURE_2D}d._MAX_COLOR_ATTACHMENTS=-1},49266:(C,D,c)=>{c.d(D,{r:()=>i});var M=c(57596),O=c(67969);class i{constructor(g,N){this._context=g,this._desc=N,this.type="renderbuffer",this._context.instanceCounter.increment(O._g.Renderbuffer,this);const e=this._context.gl;this.glName=e.createRenderbuffer(),this._context.bindRenderbuffer(this);const{width:n,height:E,internalFormat:p,multisampled:_}=N;if(_){if(this._context.type!==M.zO.WEBGL2)throw new Error("Multisampled renderbuffers are not supported in WebGL1!");e.renderbufferStorageMultisample(e.RENDERBUFFER,this.samples,p,n,E)}else e.renderbufferStorage(e.RENDERBUFFER,p,n,E)}get descriptor(){return this._desc}get samples(){const g=this._desc.samples,N=this._context.parameters.maxSamples;return g?Math.min(g,N):N}resize(g,N){const e=this._desc;if(e.width===g&&e.height===N)return;e.width=g,e.height=N;const n=this._context.gl;this._context.bindRenderbuffer(this),e.multisampled?n.renderbufferStorageMultisample(n.RENDERBUFFER,this.samples,e.internalFormat,e.width,e.height):n.renderbufferStorage(n.RENDERBUFFER,e.internalFormat,e.width,e.height)}dispose(){this._context&&(this._context.gl.deleteRenderbuffer(this.glName),this._context.instanceCounter.decrement(O._g.Renderbuffer,this),this._context=null)}}},26906:(C,D,c)=>{c.d(D,{XP:()=>e,RG:()=>E,HH:()=>S,un:()=>p,UF:()=>n,_V:()=>g}),c(8314);var O=c(62208),i=c(67969);function S(_){const d=_.gl;switch(d.getError()){case d.NO_ERROR:return null;case d.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case d.INVALID_VALUE:return"A numeric argument is out of range";case d.INVALID_OPERATION:return"The specified command is not allowed for the current state";case d.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case d.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case d.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function g(_,d){return _.vertexBuffers[d].size/function N(_){return _[0].stride}(_.layout[d])}function e(_,d,s,a,u=0){const l=_.gl,T=_.capabilities.instancing;_.bindBuffer(s);for(const h of a){const b=d.get(h.name);void 0===b&&console.error(`There is no location for vertex attribute '${h.name}' defined.`);const m=u*h.stride;if(h.count<=4)l.vertexAttribPointer(b,h.count,h.type,h.normalized,h.stride,h.offset+m),l.enableVertexAttribArray(b),h.divisor>0&&T&&T.vertexAttribDivisor(b,h.divisor);else if(9===h.count)for(let t=0;t<3;t++)l.vertexAttribPointer(b+t,3,h.type,h.normalized,h.stride,h.offset+12*t+m),l.enableVertexAttribArray(b+t),h.divisor>0&&T&&T.vertexAttribDivisor(b+t,h.divisor);else if(16===h.count)for(let t=0;t<4;t++)l.vertexAttribPointer(b+t,4,h.type,h.normalized,h.stride,h.offset+16*t+m),l.enableVertexAttribArray(b+t),h.divisor>0&&T&&T.vertexAttribDivisor(b+t,h.divisor);else console.error("Unsupported vertex attribute element count: "+h.count)}}function n(_,d,s,a){const u=_.gl,l=_.capabilities.instancing;_.bindBuffer(s);for(const T of a){const h=d.get(T.name);if(T.count<=4)u.disableVertexAttribArray(h),T.divisor&&T.divisor>0&&l&&l.vertexAttribDivisor(h,0);else if(9===T.count)for(let b=0;b<3;b++)u.disableVertexAttribArray(h+b),T.divisor&&T.divisor>0&&l&&l.vertexAttribDivisor(h+b,0);else if(16===T.count)for(let b=0;b<4;b++)u.disableVertexAttribArray(h+b),T.divisor&&T.divisor>0&&l&&l.vertexAttribDivisor(h+b,0);else console.error("Unsupported vertex attribute element count: "+T.count)}_.unbindBuffer(i.w0.ARRAY_BUFFER)}function E(_){switch(_){case i.VI.ALPHA:case i.VI.LUMINANCE:case i.VI.RED:case i.VI.RED_INTEGER:case i.lP.R8:case i.lP.R8I:case i.lP.R8UI:case i.lP.R8_SNORM:case i.Tg.STENCIL_INDEX8:return 1;case i.VI.LUMINANCE_ALPHA:case i.VI.RG:case i.VI.RG_INTEGER:case i.lP.RGBA4:case i.lP.R16F:case i.lP.R16I:case i.lP.R16UI:case i.lP.RG8:case i.lP.RG8I:case i.lP.RG8UI:case i.lP.RG8_SNORM:case i.lP.RGB565:case i.lP.RGB5_A1:case i.Tg.DEPTH_COMPONENT16:return 2;case i.VI.DEPTH_COMPONENT:case i.VI.RGB:case i.VI.RGB_INTEGER:case i.lP.RGB8:case i.lP.RGB8I:case i.lP.RGB8UI:case i.lP.RGB8_SNORM:case i.lP.SRGB8:case i.Tg.DEPTH_COMPONENT24:return 3;case i.VI.DEPTH_STENCIL:case i.VI.RGBA:case i.VI.RGBA_INTEGER:case i.lP.RGBA8:case i.lP.R32F:case i.lP.R11F_G11F_B10F:case i.lP.RG16F:case i.lP.R32I:case i.lP.R32UI:case i.lP.RG16I:case i.lP.RG16UI:case i.lP.RGBA8I:case i.lP.RGBA8UI:case i.lP.RGBA8_SNORM:case i.lP.SRGB8_ALPHA8:case i.lP.RGB9_E5:case i.lP.RGB10_A2UI:case i.lP.RGB10_A2:case i.Tg.DEPTH_STENCIL:case i.Tg.DEPTH_COMPONENT32F:case i.Tg.DEPTH24_STENCIL8:return 4;case i.Tg.DEPTH32F_STENCIL8:return 5;case i.lP.RGB16F:case i.lP.RGB16I:case i.lP.RGB16UI:return 6;case i.lP.RG32F:case i.lP.RG32I:case i.lP.RG32UI:case i.lP.RGBA16F:case i.lP.RGBA16I:case i.lP.RGBA16UI:return 8;case i.lP.RGB32F:case i.lP.RGB32I:case i.lP.RGB32UI:return 12;case i.lP.RGBA32F:case i.lP.RGBA32I:case i.lP.RGBA32UI:return 16;case i.q_.COMPRESSED_RGB_S3TC_DXT1_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case i.q_.COMPRESSED_RGBA_S3TC_DXT3_EXT:case i.q_.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case i.q_.COMPRESSED_R11_EAC:case i.q_.COMPRESSED_SIGNED_R11_EAC:case i.q_.COMPRESSED_RGB8_ETC2:case i.q_.COMPRESSED_SRGB8_ETC2:case i.q_.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.q_.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case i.q_.COMPRESSED_RG11_EAC:case i.q_.COMPRESSED_SIGNED_RG11_EAC:case i.q_.COMPRESSED_RGBA8_ETC2_EAC:case i.q_.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}function p(_){if((0,O.Wi)(_))return 0;if("descriptor"in _)return _.glName?p(_.descriptor):0;const d=_.internalFormat||"pixelFormat"in _&&_.pixelFormat;if(!d)return 0;const s="hasMipmap"in _&&_.hasMipmap?1.3:1,a=_.width*_.height;return E(d)*a*s}},49353:(C,D,c)=>{c.d(D,{U:()=>N});var M=c(63290),O=c(62208),i=c(67969),S=c(26906);const g=M.Z.getLogger("esri.views.webgl.VertexArrayObject");class N{constructor(n,E,p,_,d=null){this._context=n,this._locations=E,this._layout=p,this._buffers=_,this._indexBuffer=d,this._glName=null,this._initialized=!1,n.instanceCounter.increment(i._g.VAO,this)}get glName(){return this._glName}get vertexBuffers(){return this._buffers}get indexBuffer(){return this._indexBuffer}get size(){return Object.keys(this._buffers).reduce((n,E)=>n+this._buffers[E].size,(0,O.pC)(this._indexBuffer)?this._indexBuffer.size:0)}get layout(){return this._layout}get locations(){return this._locations}dispose(n=!0){if(this._context){if(this._glName){var E,p;const _=null==(E=this._context)||null==(p=E.capabilities)?void 0:p.vao;_?(_.deleteVertexArray(this._glName),this._glName=null):g.warn("Leaked WebGL VAO")}if(this._context.getBoundVAO()===this&&this._context.bindVAO(null),n){for(const _ in this._buffers)this._buffers[_].dispose(),delete this._buffers[_];this._indexBuffer=(0,O.O3)(this._indexBuffer)}this._context.instanceCounter.decrement(i._g.VAO,this),this._context=null}else(this._glName||n&&Object.getOwnPropertyNames(this._buffers).length>0)&&g.warn("Leaked WebGL VAO")}initialize(){if(this._initialized)return;const n=this._context.capabilities.vao;if(n){const E=n.createVertexArray();n.bindVertexArray(E),this._bindLayout(),n.bindVertexArray(null),this._glName=E}this._initialized=!0}bind(){this.initialize();const n=this._context.capabilities.vao;n?n.bindVertexArray(this.glName):(this._context.bindVAO(null),this._bindLayout())}_bindLayout(){const{_buffers:n,_layout:E,_indexBuffer:p}=this;n||g.error("Vertex buffer dictionary is empty!");const _=this._context.gl;for(const d in n){const s=n[d];s||g.error("Vertex buffer is uninitialized!");const a=E[d];a||g.error("Vertex element descriptor is empty!"),(0,S.XP)(this._context,this._locations,s,a)}(0,O.pC)(p)&&(this._context.capabilities.vao?_.bindBuffer(_.ELEMENT_ARRAY_BUFFER,p.glName):this._context.bindBuffer(p))}unbind(){this.initialize();const n=this._context.capabilities.vao;n?n.bindVertexArray(null):this._unbindLayout()}_unbindLayout(){const{_buffers:n,_layout:E}=this;n||g.error("Vertex buffer dictionary is empty!");for(const p in n){const _=n[p];_||g.error("Vertex buffer is uninitialized!"),(0,S.UF)(this._context,this._locations,_,E[p])}(0,O.pC)(this._indexBuffer)&&this._context.unbindBuffer(this._indexBuffer.bufferType)}}}}]);